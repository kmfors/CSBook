
# 不变式

什么是不变式？一条假定某事为真的声明称为类的不变式。建立类的不变式是构造函数的任务？成员函数可以依赖于该函数不变式？另一作用是确保当成员函数退出时不变式仍然成立。

比如说，构造函数在执行时，虽然有给数据成员传参，但是却没有校验传的实参是否有效；如果无效，很有可能函数在执行一半时崩掉，从而影响了原有功能的完全执行（因为我们假定构造函数是不可能崩的）。

---
# 静态断言：
大多数系统以及自定义类型接口的主要目的就是能够在编译时发现错误。

把表达某种期望的语句称为断言（assertion），比如说static_assert机制（作用于任何可以表达为常量表达式的东西）

比如：static_assert(A, S)的作用是当A不为true时，把S作为一条编译器错误信息输出。主要用于为泛型编程中作为形参的类型设置断言。

# 抑制操作
对于层次中的类来说，使用默认的拷贝或移动操作常常意味着风险：因为只给出一个基类的指针，我们无法了解派生类有什么样的成员，当然也就不知道如何操作它们。因此，最好的做法就是删除掉默认的拷贝和移动操作。
避免用这两个操作的默认定义。

# 函数对象
正因为函数对象具有可携带数据和高效这两个特性，我们经常用其作为算法的实参。

用于指明通用算法关键操作含义的函数对象被称为策略对象（policy object）

但是将函数对象的定义和使用分离开有点麻烦，因而提供了隐式生成函数对象的表示法：lambda表达式

![[第一部分：引言.png]]

迭代器的一个重要作用是分离算法和容器。算法通过迭代器来处理数据，但它对存储单元的容器一无所知。反之亦然，容器对处理元素的算法也是一无所知，它所作的全部事情就是按需求提供迭代器。这种数据存储和算法分离的模型催生出非常通用和灵活的软件。

算法都是对序列中的每个元素简单的进行“内置”操作，但我们常常需要把操作也作为算法的参数。---谓词

# 资源管理

所有的程序都包含一项关键任务：管理资源。所谓资源是指程序中符合先获取后释放规律的东西，比如内存、锁、套接字、线程句柄和文件句柄。

RAII：资源获取即初始化。

- 保持任务的并发隔离（不会同时使用共享数据）：注意避免即可
- 共享数据的访问必须保持同步（同一时刻至多有一个任务访问数据）：用mutex

共享对象与锁逐渐成为一种常规的对应关系，但加锁解锁的操作也很耗时间，注意在什么样的场景下才会去选择共享数据的方式来进行线程间的通信。

通过外部事件实现线程间通信的基本方法是使用 condition_variable(允许一个thread通过某种条件等待另一个thread)

标准库提供了一些特性，允许程序员在抽象的任务层（工作并发执行）进行操作，而不是在底层的线程和锁的层次直接进行操作。

![[第一部分：引言-1.png]]

```c++
std::promise<T> px;
T res;
px.set_value(res); // 计算一个值，保存在res
// 将异常传递给future的线程
px.set_exception(current_exception());

future<T> fx;
fx.get(); // 等待值准备好
```

![[第一部分：引言-2.png]]
![[第一部分：引言-3.png]]

注意要遵循的思路是：**将任务当作可以与其他任务并发执行的函数来处理！**

![[第一部分：引言-4.png]]

---
time_point 时间点 ， duration 时间段

类型函数是指在编译时求值的函数，它接受一个类型作为实参或者返回一个类型作为结果，比如说`std::numeric_limits<float>::min()` 最小的正浮点数。

使用类型函数的用法称为元编程。

iterator_traits机制检查当前容器支持哪种迭代器。这一部分有点高深，放在后面以后加强。

![[第一部分：引言-5.png]]

类型谓词 与 pair和tuple，tuple表示任意形式的元素序列。

随机数生成器包括两部分：
- 一个引擎（engine），负责生成一组随机值或者伪随机值。
- 一种分布（distribution），负责把引擎生成的值映射到某个数学分布上。
常用的分布包括：uniform_int_distribution、normal_distribution（正太分布）、exponential_distribution(指数增长)

准备看第六章了



















































