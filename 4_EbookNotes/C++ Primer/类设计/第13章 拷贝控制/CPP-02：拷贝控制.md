
# 一、设计工具
## 拷贝构造函数

拷贝构造函数：该函数的第一个参数必须是自身类类型的引用，且任何额外参数都有默认值。如果类中没有定义一个拷贝构造函数，编译会默认生成一个合成拷贝构造函数。它作用于对象的初始化。

合成拷贝构造函数的意义：

1. 少数情况下，阻止拷贝该类类型的对象（例如一些情况下默认生成的 =delete ）
2. 一般情况下，从给定对象依次将每个非 const 成员拷贝到正在创建的对象中。

声明定义：

```c++
class Foo {
    Foo(const Foo&);
};
```


拷贝初始化：

```c++
// 直接初始化
string s1("str copy");
string s2(s1);

// 拷贝初始化
string s3 = s1;
string s4 = "hello,world";
string s5 = string("good morning");
```

直接初始化：要求编译器使用普通的函数匹配，来选择提供参数匹配的构造函数。

拷贝初始化：要求编译器将右侧运算对象拷贝到正在创建的对象中,如有需要还有进行类型转换。被隐式调用的情况有：

- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 花括号列表初始化一个数组中的元素或一个聚合类中的成员

某些类类型还会对它们所分配的对象使用拷贝初始化。例如，使用标准库容器调用其 insert 或 push 成员时，容器会对其元素进行拷贝初始化。与之相对，对 emplace 成员创建的元素都进行直接初始化。

拷贝构造函数通常不应该是 explicit（显式） 的，因为虽然可以定义非 const 引用的拷贝构造函数，但此参数几乎总是一个 const 的引用。如果我们使用一个 explicit 构造函数，就必须显式使用（直接初始化），不能通过赋值运算符来初始化一个对象。

> [!WARNING]
>
> 1、为什么拷贝构造函数里的参数是 const 引用类型呢？




## 拷贝赋值运算符

拷贝赋值运算符：类内重载赋值运算符，返回类型为类类型引用。如果类未定义自己的拷贝赋值运算符，编译器默认生成一个合成拷贝赋值运算符。它作用于对象（已初始化）间的赋值。

合成拷贝赋值运算符的意义：

1. 少数情况下，禁止该类型对象的赋值（例如一些情况下默认生成的 =delete ）。
2. 一般情况下，将右侧运算对象的每个非 static 成员赋予左侧运算对象的对应成员。

声明定义：

```c++
class Foo {
    Foo& operator=(const Foo&);
};
```

赋值给对象：

```c++
string s1, s2;

s1 = string("hello,world");
s2 = s1;
```


## 移动构造函数

移动构造函数：该函数的第一个参数必须是该类类型的一个右值引用，且任何额外参数都有默认值。

意义：完成资源的移动，源对象必须不再指向被移动的资源。所有权发生转换。

声明定义：

```c++
class Foo {
    Foo(Foo&&) noexcept {}
};
```

noexcept：通知标准库我们的构造函数不抛出任何异常。


## 移动赋值运算符

移动赋值运算符：类内重载赋值运算符，返回类型为类类型引用。

声明定义：

```c++
class Foo {
    Foo& operator=(Foo&&) noexcept {}
};
```

移动之后的源对象必须可析构。

## 析构函数

析构函数：释放对象使用的资源，并销毁对象的非 static 数据成员。当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数。

```c++
class Foo {
    ~Foo(){} // 析构函数
};
```

在一个析构函数中，首先执行的是函数体，然会执行析构部分，销毁成员。成员按初始化顺序的逆序销毁。通常，析构函数释放对象在生存期分配的资源。析构函数执行析构部分是隐式的。

调用时机：

![[20240721145213.png]]

> [!NOTE]
>
> 1、当指向一个对象的引用或指针离开作用域时，析构函数不会执行。
> 
> 2、隐式销毁一个内置指针类型的成员不会 delete 它所指向的对象。



# 二、延伸扩展

## 三五法则

如前所述，有三个基本操作就可以控制类的拷贝操作：拷贝构造、拷贝赋值和析构函数。C++并不要求我们定义上面所说的所有操作，可以之定义其中一个或两个。

> [!NOTE]
>
> 1、需要析构函数的类也需要拷贝和赋值操作。（如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符）
> 
> 2、需要拷贝操作的类也需要赋值操作，反之亦然。然而，无论是需要拷贝构造还是需要拷贝赋值运算符，都不必然意味着也需要析构函数。



## =default 操作

我们可以通过将拷贝控制成员定义为 =default 来显式地要求编译器生成合成地版本。当我们在类内用 =default 修饰成员地声明时，合成地函数将隐式地声明为内敛。如果不希望时内敛函数，那应该只对成员地类外定义使用 =default 。

我们只能对具有合成版本地成员函数使用 =default（即，默认构造函数或拷贝控制成员）。


## =delete 操作

某种情况，定义类时必须采用某种机制阻止拷贝或赋值。例如，iostream 类阻止了拷贝，以避免多个对象写入或读取相同地 IO 缓冲。我们可以使用 =delete 将拷贝构造函数和拷贝赋值运算符定义为删除地函数来阻止拷贝。即，虽然我们声明了它们，但不能以任何方式使用它们。

=delete 必须在函数第一次声明地时候进行修饰，并且可以对任何函数指定 =delete。

![[20240721152205.png]]

> [!CAUTION]
>
> 1、如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则对应地成员函数将被定义为 delete 的。
>
> 2、对于有引用成员的类，合成拷贝赋值运算符被定义为 delete 的。

> [!TIP]
>
> private 拷贝控制：通过声明（但不定义）private 的拷贝构造函数，我们可以预先阻止任何拷贝该类型对象的企图。
>
> 1、试图拷贝对象的用户代码在编译阶段被标记为错误；
>
> 2、成员函数或友元函数中的拷贝操作将会导致链接时错误。

