# 内容概要

当定义一个类时，我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：

- 拷贝构造函数
- 拷贝赋值运算符
- 移动构造函数
- 移动赋值运算符
- 析构函数

拷贝与移动构造函数：当用同类型的另一个对象初始化本对象时需要做的处理。

拷贝和移动赋值运算符：将一个对象赋予同类型的另一个对象时需要做的处理。

析构函数：定义当此类型对象销毁时做什么。

我们称上面的五个操作为拷贝控制操作（copy control），**如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作**。

---
## 操作语义

通常，管理类外资源的类必须定义拷贝控制成员。为了定义这些成员，首先我们必须要明确此类型对象的拷贝语义。

拷贝语义的参考标准：使类的行为看起来像一个值或者一个指针。可以像值一样操作类的行为的，称该类拥有值语义；可以像指针一样操作类的行为的，称该类拥有移动语义。


## 对象移动

在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，尤其是对象较大或对象本身要求分配内存空间，进行不必要的拷贝代价非常高，因此更好的方式是移动元素。并且像 IO 类或 unique_ptr 这样的类都包含不能被共享的资源，所以这些类型的对象不能拷贝但可以移动。

为了支持移动操作，从而引入了右值引用。左值和右值是表达式的属性。右值引用就是必须绑定到右值的引用，只能绑定到一个将要销毁的对象。

- 右值引用不能绑定到一个左值上。
- 右值引用不能绑定到一个右值引用类型的变量。
- 可以将一个 const 的左值引用或一个右值引用绑定到这类右值表达式上

```c++
int i = 32;

// const的左值引用，绑定到右值
const int& r1 = i * 2;

int&& r2 = i * 3;
```


左值有持久的状态，右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。由于右值引用只能绑定到临时对象上，从而可知右值引用的两个特性：

- 所引用的对象将要销毁
- 该对象没有其他用户

这两个特性使得，使用右值引用的代码可以自由地接管所引用的对象的资源。

> [!IMPORTANT]
>
> 1、只有当一个类没有定义任何版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。
>
> 2、移动操作永远不会隐式定义为删除的函数。但如果我们显式要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。
>
> 3、如果类定义了移动构造和或一个移动赋值，则该类的合成拷贝构造与拷贝赋值会被定义为删除的。
>
> 4、如果一个类既有移动构造，也有拷贝构造，编译器将使用普通的函数匹配规则来确定使用哪个函数。赋值操作情况类似。


## 移动迭代器

