Dual ABI（Application Binary Interface）是指在一个程序中同时支持两种不同的 ABI。

ABI 是一组规则和约定，用于定义如何在计算机系统中表示数据类型、如何调用函数等。不同的编程语言和编译器可能有不同的 ABI。

在某些情况下，可能需要在一个程序中同时使用两种不同的 ABI。例如，在 C++中，可以使用 extern "C"关键字来告诉编译器按照 C 语言的 ABI 来处理某个函数。这样，可以在 C++代码中调用 C 语言编写的函数库。

另一个例子是在跨平台开发中，可能需要在不同的操作系统和硬件架构上运行相同的代码。为了实现这一点，可以使用条件编译和其他技术来确保代码在不同的平台上使用正确的 ABI。

---

https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_dual_abi.html

在 GCC 5.1 版本中，libstdc++ 引入了新的库 ABI，其中包括对 std::string 和 std::list 的新实现。为了符合 2011 年的 C++ 标准，这些改动是必要的，因为该标准禁止写入时复制字符串，并要求列表记录其大小。

为了保持链接到 libstdc++ 的现有代码的向后兼容性，该库的 soname 没有改变，旧的实现仍与新的实现并行支持。为此，我们在内联命名空间中定义了新的实现，这样它们在链接时就有了不同的名称，例如，新版本的 `std::list<int>` 实际上被定义为 `std::__cxx11::list<int>`。由于新实现的符号具有不同的名称，因此两个版本的定义可以出现在同一个库中。

`_GLIBCXX_USE_CXX11_ABI` 宏（参见宏）控制着库头文件中的声明是使用旧的还是新的 ABI。因此，可以针对编译的每个源文件分别决定使用哪种 ABI。使用 GCC 的默认配置选项时，宏的默认值为 1，这将导致新的 ABI 被激活，因此要使用旧的 ABI，必须在包含任何库头文件之前将宏明确定义为 0。 (请注意，某些 GNU/Linux 发行版对 GCC 5 的配置有所不同，因此该宏的默认值为 0，用户必须将其定义为 1 才能启用新的 ABI）。

虽然这些更改是为了与 C++11 保持一致，但选择使用哪种 ABI 与编译代码时使用的 -std 选项无关，也就是说，对于给定的 GCC 编译，`_GLIBCXX_USE_CXX11_ABI` 宏的默认值对所有方言都是相同的。
这样可以确保 `-std` 不会改变 ABI，从而可以直接将 C++03 和 C++11 代码连接在一起。

由于 std::string 在整个库中被广泛使用，其他一些类型也被定义了两次，其中包括 stringstream 类和 std::locale 使用的几个面。在两种 ABI 中，始终安装在一个本地语言中的标准刻面可能会出现两次，以确保类似 `std::use_facet<std::time_get<char>>(locale);` 这样的代码能同时正确地用于 `std::time_get` 和 `std::__cxx11::time_get`（即使本地语言中安装了派生自某个或其他版本 time_get 的用户定义刻面）。

虽然 `<stdexcept>` 中定义的标准异常类型使用字符串，但大多数异常类型都不会被定义两次，因此在一个文件中抛出的 std::out_of_range 异常总能被另一个文件中的合适处理程序捕获，即使这两个文件是用不同的 ABI 编译的。

在使用新 ABI 时，有一种异常类型会发生变化，即 std::ios_base::failure。这是必要的，因为 2011 年标准将其基类从 std::exception 更改为 std::system_error，这导致其布局发生变化。由于 iostream 错误导致的异常是由 libstdc++.so 内部的函数抛出的，因此抛出的异常是使用旧的 std::ios_base::failure 类型，还是使用新的 std::ios_base::failure 类型，取决于构建 libstdc++.so 时使用的 ABI，而不是使用 iostreams 的用户代码中使用的 ABI。这意味着对于特定的 GCC 版本，抛出的类型是固定的。在当前版本中，函数库会抛出一种特殊类型，新旧类型的处理程序都能捕获这种类型的异常，但在 GCC 7.1、7.2 和 7.3 中，函数库会抛出新的 std::ios_base::failure 类型，而在 GCC 5.x 和 6.x 中，函数库会抛出旧的类型。 std::ios_base::failure 类型的捕获处理程序只有在使用较新版本，或处理程序的编译 ABI 与库抛出的类型相同时，才能捕获异常。 std::exception 的处理程序将始终捕获 iostreams 异常，因为新旧类型都继承自 std::exception。

# 故障排除

如果出现链接器错误，提示涉及 `std::__cxx11` 命名空间中的类型或标记 `[abi:cxx11]` 的未定义引用符号，那么这可能表明您正在尝试将使用不同的 `_GLIBCXX_USE_CXX11_ABI` 宏值编译的对象文件链接到一起。这种情况通常发生在链接到使用旧版本 GCC 编译的第三方库时。如果第三方库无法使用新的 ABI 重新编译，则需要使用旧的 ABI 重新编译代码。

并非所有新 ABI 的使用都会导致符号名称的变化，例如，一个带有 std::string 成员变量的类，无论使用新旧 ABI 编译，其名称都是一样的。为了检测此类问题，新的类型和函数都标注了 abi_tag 属性，允许编译器对使用这些类型和函数的代码中可能出现的 ABI 不兼容情况发出警告。这些警告可以通过 -Wabi-tag 选项启用。