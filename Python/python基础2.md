

# 变量

变量的类型检查函数：type()

变量的类型转换函数：

- `int()`：将一个数值或字符串转换成整数，可以指定进制。
- `float()`：将一个字符串转换成浮点数。
- `str()`：将指定的对象转换成字符串形式，可以指定编码。
- `chr()`：将整数转换成该编码对应的字符串（一个字符）。
- `ord()`：将字符串（一个字符）转换成对应的编码（整数）。

```python
a = 100
b = 12.345
c = 'hello, world'
d = True
# 整数转成浮点数
print(float(a))    # 100.0
# 浮点型转成字符串 (输出字符串时不会看到引号哟)
print(str(b))      # 12.345
# 字符串转成布尔型 (有内容的字符串都会变成True)
print(bool(c))     # True
# 布尔型转成整数 (True会转成1，False会转成0)
print(int(d))      # 1
# 将整数变成对应的字符 (97刚好对应字符表中的字母a)
print(chr(97))     # a
# 将字符转成整数 (Python中字符和字符串表示法相同)
print(ord('a'))    # 97
```

在 Python 程序中，我们可以**使用变量来保存数据，变量有不同的类型，变量可以做运算，也可以通过内置函数来转换变量类型**。

# 运算符

Python 语言支持很多种运算符。

| 运算符                                                       | 描述                           |
| ------------------------------------------------------------ | ------------------------------ |
| `[]` `[:]`                                                   | 下标，切片                     |
| `**`                                                         | 指数                           |
| `~` `+` `-`                                                  | 按位取反, 正负号               |
| `*` `/` `%` `//`                                             | 乘，除，模，整除               |
| `+` `-`                                                      | 加，减                         |
| `>>` `<<`                                                    | 右移，左移                     |
| `&`                                                          | 按位与                         |
| `^` `\|`                                                     | 按位异或，按位或               |
| `<=` `<` `>` `>=`                                            | 小于等于，小于，大于，大于等于 |
| `==` `!=`                                                    | 等于，不等于                   |
| `is`  `is not`                                               | 身份运算符                     |
| `in` `not in`                                                | 成员运算符                     |
| `not` `or` `and`                                             | 逻辑运算符                     |
| `=` `+=` `-=` `*=` `/=` `%=` `//=` `**=` `&=` `\|=` `^=` `>>=` `<<=` | （复合）赋值运算符             |

>**说明：** 上面这个表格实际上是按照运算符的优先级从上到下列出了各种运算符。所谓优先级就是在一个运算的表达式中，如果出现了多个运算符，应该先执行哪个运算再执行哪个运算的顺序。在实际开发中，如果搞不清楚运算符的优先级，可以使用圆括号来确保运算的执行顺序。

## 算术运算符

Python 中的算术运算符非常丰富，除了大家最为熟悉的加减乘除之外，还有整除运算符、求模（求余数）运算符和求幂运算符。下面的例子为大家展示了算术运算符的使用。

```Python
print(321 + 123)     # 加法运算
print(321 - 123)     # 减法运算
print(321 * 123)     # 乘法运算
print(321 / 123)     # 除法运算
print(321 % 123)     # 求模运算
print(321 // 123)    # 整除运算
print(321 ** 123)    # 求幂运算
```

## 赋值运算符

赋值运算符应该是最为常见的运算符，它的作用是将右边的值赋给左边的变量。下面的例子演示了赋值运算符和复合赋值运算符的使用。

```Python
a = 10
b = 3
a += b        # 相当于：a = a + b
a *= a + 2    # 相当于：a = a * (a + 2)

print(a)      # 算一下这里会输出什么
```

## 比较运算符和逻辑运算符

比较运算符有的地方也称为关系运算符，包括 `==`、`!=`、`<`、`>`、`<=`、`>=`。，需要提醒的是比较相等用的是 `==`，请注意这里是两个等号，因为 `=` 是赋值运算符，`==` 才是比较相等的运算符；比较不相等用的是 `!=`，这不同于数学上的不等号。比较运算符会产生布尔值，要么是 `True` 要么是 `False`。

逻辑运算符有三个，分别是 `and`、`or` 和 `not`，即对应的是与或非。

```Python
flag0 = 1 == 1
flag1 = 3 > 2
flag2 = 2 < 1
flag3 = flag1 and flag2
flag4 = flag1 or flag2
flag5 = not (1 != 2)
print('flag0 =', flag0)    # flag0 = True
print('flag1 =', flag1)    # flag1 = True
print('flag2 =', flag2)    # flag2 = False
print('flag3 =', flag3)    # flag3 = False
print('flag4 =', flag4)    # flag4 = True
print('flag5 =', flag5)    # flag5 = False
```

> **说明**：比较运算符的优先级高于赋值运算符，所以 `flag0 = 1 == 1` 先做 `1 == 1` 产生布尔值 `True`，再将这个值赋值给变量 `flag0`。`print` 函数可以输出多个值，多个值之间可以用 `,` 进行分隔，输出的内容之间默认以空格分开。


## 例1：华氏温度转换为摄氏温度

**提示**：华氏温度到摄氏温度的转换公式为：`C = (F - 32) / 1.8`

```Python
f = float(input('请输入华氏温度: '))
c = (f - 32) / 1.8
print('%.1f华氏度 = %.1f摄氏度' % (f, c))
```

> **说明**：在使用 `print` 函数输出时，也可以对字符串内容进行格式化处理，上面 `print` 函数中的字符串 `%.1f` 是一个占位符，稍后会由一个 `float` 类型的变量值替换掉它。同理，如果字符串中有 `%d`，后面可以用一个 `int` 类型的变量值替换掉它，而 `%s` 会被字符串的值替换掉。除了这种格式化字符串的方式外，还可以用下面的方式来格式化字符串，其中 `{f:.1f}` 和 `{c:.1f}` 可以先看成是 `{f}` 和 `{c}`，表示输出时会用变量 `f` 和变量 `c` 的值替换掉这两个占位符，后面的 `:.1f` 表示这是一个浮点数，小数点后保留1位有效数字。

```Python
print (f'{f:. 1 f}华氏度 = {c:. 1 f}摄氏度')
```

## 例2：输入圆的半径计算计算周长和面积

```Python
radius = float(input('请输入圆的半径: '))
perimeter = 2 * 3.1416 * radius
area = 3.1416 * radius * radius
print('周长: %.2f' % perimeter)
print('面积: %.2f' % area)
```

## 例3：输入年份判断是不是闰年

```Python
year = int(input('请输入年份: '))
is_leap = year % 4 == 0 and year % 100 != 0 or year % 400 == 0
print(is_leap)
```

> **说明**：比较运算符会产生布尔值，而逻辑运算符 `and` 和 `or` 会对这些布尔值进行组合，最终也是得到一个布尔值，闰年输出 `True`，平年输出 `False`。



# 数据结构之字符串


## 字符串的定义

所谓**字符串**，就是**由零个或多个字符组成的有限序列**，一般记为：
$$
s = a_1a_2 \cdots a_n \,\,\,\,\, (0 \le n \le \infty)
$$
在 Python 程序中，如果我们把单个或多个字符用单引号或者双引号包围起来，就可以表示一个字符串。字符串中的字符可以是特殊符号、英文字母、中文字符、日文的平假名或片假名、希腊字母、[Emoji字符](<http://www.ruanyifeng.com/blog/2017/04/emoji.html>)等。

```Python
s1 = 'hello, world!'
s2 = "你好，世界！"
print(s1, s2)
# 以三个双引号或单引号开头的字符串可以折行
s3 = '''
hello, 
world!
'''
print(s3, end='')
```

> **提示**：`print` 函数中的 `end=''` 表示输出后不换行，即将默认的结束符 `\n`（换行符）更换为 `''`（空字符）。

## 转义字符和原始字符串

可以在字符串中使用 `\`（反斜杠）来表示转义，也就是说 `\` 后面的字符不再是它原来的意义，例如：`\n` 不是代表反斜杠和字符 `n`，而是表示换行；`\t` 也不是代表反斜杠和字符 `t`，而是表示制表符。所以如果字符串本身又包含了 `'`、`"`、`\` 这些特殊的字符，必须要通过 `\` 进行转义处理。例如要输出一个带单引号或反斜杠的字符串，需要用如下所示的方法。

```Python
s1 = '\'hello, world!\''
print(s1)
s2 = '\\hello, world!\\'
print(s2)
```

Python 中的字符串可以 `r` 或 `R` 开头，这种字符串被称为原始字符串，意思是字符串中的每个字符都是它本来的含义，没有所谓的转义字符。例如，在字符串 `'hello\n'` 中，`\n` 表示换行；而在 `r'hello\n'` 中，`\n` 不再表示换行，就是反斜杠和字符 `n`。大家可以运行下面的代码，看看会输出什么。

```Python
# 字符串s1中\t是制表符，\n是换行符
s1 = '\time up \now'
print(s1)
# 字符串s2中没有转义字符，每个字符都是原始含义
s2 = r'\time up \now'
print(s2)
```

Python 中还允许在 `\` 后面还可以跟一个八进制或者十六进制数来表示字符，例如 `\141` 和 `\x61` 都代表小写字母 `a`，前者是八进制的表示法，后者是十六进制的表示法。另外一种表示字符的方式是在 `\u` 后面跟 Unicode 字符编码，例如 `\u9a86\u660a` 代表的是中文“骆昊”。运行下面的代码，看看输出了什么。

```Python
s1 = '\141\142\143\x61\x62\x63'
s2 = '\u9a86\u660a'
print(s1, s2)
```

## 字符串的运算

Python 为字符串类型提供了非常丰富的运算符，我们可以使用 `+` 运算符来实现字符串的拼接，可以使用 `*` 运算符来重复一个字符串的内容，可以使用 `in` 和 `not in` 来判断一个字符串是否包含另外一个字符串，我们也可以用 `[]` 和 `[:]` 运算符从字符串取出某个字符或某些字符。

#### 拼接和重复

下面的例子演示了使用 `+` 和 `*` 运算符来实现字符串的拼接和重复操作。

```Python
s1 = 'hello' + ' ' + 'world'
print(s1)    # hello world

s2 = '!' * 3
print(s2)    # !!!

s1 += s2     # s1 = s1 + s2
print(s1)    # hello world!!!

s1 *= 2      # s1 = s1 * 2
print(s1)    # hello world!!!hello world!!!
```

用 `*` 实现字符串的重复是非常有意思的一个运算符，在很多编程语言中，要表示一个有 10 个 `a` 的字符串，你只能写成 `"aaaaaaaaaa"`，但是在 Python 中，你可以写成 `'a' * 10`。你可能觉得 `"aaaaaaaaaa"` 这种写法也没有什么不方便的，那么想一想，如果字符 `a` 要重复 100 次或者 1000次又会如何呢？

### 比较运算

对于两个字符串类型的变量，可以直接使用比较运算符比较两个字符串的相等性或大小。需要说明的是，因为字符串在计算机内存中也是以二进制形式存在的，那么字符串的大小比较比的是每个字符对应的编码的大小。例如 `A` 的编码是 `65`，而 `a` 的编码是 `97`，所以 `'A' < 'a'` 的结果相当于就是 `65 < 97` 的结果，很显然是 `True`；而 `'boy' < 'bad'`，因为第一个字符都是 `'b'` 比不出大小，所以实际比较的是第二个字符的大小，显然 `'o' < 'a'` 的结果是 `False`，所以 `'boy' < 'bad'` 的结果也是 `False`。如果不清楚**两个字符对应的编码到底是多少，可以使用 `ord` 函数来获得**，例如 `ord('A')` 的值是 `65`，而 `ord('昊')` 的值是 `26122`。下面的代码为大家展示了字符串的比较运算。

```Python
s1 = 'a whole new world'
s2 = 'hello world'
print(s1 == s2, s1 < s2)      # False True
print(s2 == 'hello world')    # True
print(s2 == 'Hello world')    # False
print(s2 != 'Hello world')    # True

s3 = '张三'
print(ord('张'), ord('三'))    # 24352 19977
s4 = '李四'
print(ord('李'), ord('四'))    # 26446 22235

print(s3 > s4, s3 <= s4)      # False True
```

需要强调一下的是，字符串的比较运算比较的是字符串的内容，Python 中还有一个 `is` 运算符（身份运算符），如果用 `is` 来比较两个字符串，它比较的是两个变量对应的字符串对象的内存地址（不理解先跳过），简单的说就是两个变量是否对应内存中的同一个字符串。看看下面的代码就比较清楚 `is` 运算符的作用了。

```Python
s1 = 'hello world'
s2 = 'hello world'
s3 = s2
# 比较字符串的内容
print(s1 == s2, s2 == s3)    # True True
# 比较字符串的内存地址
print(s1 is s2, s2 is s3)    # False True
```

### 成员运算

Python 中可以用 `in` 和 `not in` 判断一个字符串中是否存在另外一个字符或字符串，`in` 和 `not in` 运算通常称为成员运算，会产生布尔值 `True` 或 `False`，代码如下所示。

```Python
s1 = 'hello, world'
print('wo' in s1)    # True

s2 = 'goodbye'
print(s2 in s1)      # False
```

### 获取字符串长度

获取字符串长度没有直接的运算符，而是使用内置函数 `len`，我们在上节课的提到过这个内置函数，代码如下所示。

```Python
s = 'hello, world'
print(len(s))                   # 12
print(len('goodbye, world'))    # 14
```

### 索引和切片

如果希望从字符串中取出某个字符，我们可以对字符串进行索引运算，运算符是 `[n]`，其中 `n` 是一个整数，假设字符串的长度为 `N`，那么 `n` 可以是从 `0` 到 `N-1` 的整数，其中 `0` 是字符串中第一个字符的索引，而 `N-1` 是字符串中最后一个字符的索引，通常称之为正向索引；在 Python 中，字符串的索引也可以是从 `-1` 到 `-N` 的整数，其中 `-1` 是最后一个字符的索引，而 `-N` 则是第一个字符的索引，通常称之为负向索引。注意，因为**字符串是不可变类型**，所以**不能通过索引运算修改字符串中的字符**。

```Python
s = 'abc123456'
N = len(s)

# 获取第一个字符
print(s[0], s[-N])    # a a

# 获取最后一个字符
print(s[N-1], s[-1])  # 6 6

# 获取索引为2或-7的字符
print(s[2], s[-7])    # c c

# 获取索引为5和-4的字符
print(s[5], s[-4])    # 3 3
```

需要提醒大家注意的是，在进行索引操作时，如果索引越界（正向索引不在 `0` 到 `N-1` 范围，负向索引不在 `-1` 到 `-N` 范围），会引发 `IndexError` 异常，错误提示信息为：`string index out of range`（字符串索引超出范围）。

如果要从字符串中取出多个字符，我们可以对字符串进行切片，运算符是 `[i:j:k]`，其中 `i` 是开始索引，索引对应的字符可以取到；`j` 是结束索引，索引对应的字符不能取到；`k` 是步长，默认值为 `1`，表示从前向后获取相邻字符的连续切片，所以 `:k` 部分可以省略。假设字符串的长度为 `N`，当 `k > 0` 时表示正向切片（从前向后获取字符），如果没有给出 `i` 和 `j` 的值，则 `i` 的默认值是 `0`，`j` 的默认值是 `N`；当 `k < 0` 时表示负向切片（从后向前获取字符），如果没有给出 `i` 和 `j` 的值，则 `i` 的默认值是 `-1`，j 的默认值是 `-N - 1`。如果不理解，直接看下面的例子，记住第一个字符的索引是 `0` 或 `-N`，最后一个字符的索引是 `N-1` 或 `-1` 就行了。

```Python
s = 'abc123456'

# i=2, j=5, k=1的正向切片操作
print(s[2:5])       # c12

# i=-7, j=-4, k=1的正向切片操作
print(s[-7:-4])     # c12

# i=2, j=9, k=1的正向切片操作
print(s[2:])        # c123456

# i=-7, j=9, k=1的正向切片操作
print(s[-7:])       # c123456

# i=2, j=9, k=2的正向切片操作
print(s[2::2])      # c246

# i=-7, j=9, k=2的正向切片操作
print(s[-7::2])     # c246

# i=0, j=9, k=2的正向切片操作
print(s[::2])       # ac246

# i=1, j=-1, k=2的正向切片操作
print(s[1:-1:2])    # b135

# i=7, j=1, k=-1的负向切片操作
print(s[7:1:-1])    # 54321c

# i=-2, j=-8, k=-1的负向切片操作
print(s[-2:-8:-1])  # 54321c

# i=7, j=-10, k=-1的负向切片操作
print(s[7::-1])     # 54321cba

# i=-1, j=1, k=-1的负向切片操作
print(s[:1:-1])     # 654321c

# i=0, j=9, k=1的正向切片
print(s[:])         # abc123456

# i=0, j=9, k=2的正向切片
print(s[::2])       # ac246

# i=-1, j=-10, k=-1的负向切片
print(s[::-1])      # 654321cba

# i=-1, j=-10, k=-2的负向切片
print(s[::-2])      # 642ca
```

### 循环遍历每个字符

如果希望从字符串中取出每个字符，可以使用 `for` 循环对字符串进行遍历，有两种方式。

方式一：

```Python
s1 = 'hello'
for index in range(len(s1)):
    print(s1[index])
```

方式二：

```Python
s1 = 'hello'
for ch in s1:
    print(ch)
```

## 字符串的方法

在 Python 中，我们可以通过字符串类型自带的方法对字符串进行操作和处理，对于一个字符串类型的变量，我们可以用 `变量名.方法名()` 的方式来调用它的方法。所谓方法其实就是跟某个类型的变量绑定的函数，后面我们讲面向对象编程的时候还会对这一概念详加说明。

### 大小写相关操作

下面的代码演示了和字符串大小写变换相关的方法。

```Python
s1 = 'hello, world!'

# 使用capitalize方法获得字符串首字母大写后的字符串
print(s1.capitalize())   # Hello, world!

# 使用title方法获得字符串每个单词首字母大写后的字符串
print(s1.title())        # Hello, World!

# 使用upper方法获得字符串大写后的字符串
print(s1.upper())        # HELLO, WORLD!

s2 = 'GOODBYE'
# 使用lower方法获得字符串小写后的字符串
print(s2.lower())        # goodbye
```

### 查找操作

如果想在一个字符串中从前向后查找有没有另外一个字符串，可以使用字符串的 `find` 或 `index` 方法。

```Python
s = 'hello, world!'

# find方法从字符串中查找另一个字符串所在的位置
# 找到了返回字符串中另一个字符串首字符的索引
print(s.find('or'))        # 8
# 找不到返回-1
print(s.find('shit'))      # -1
# index方法与find方法类似
# 找到了返回字符串中另一个字符串首字符的索引
print(s.index('or'))       # 8
# 找不到引发异常
print(s.index('shit'))     # ValueError: substring not found
```

在使用 `find` 和 `index` 方法时还可以通过方法的参数来指定查找的范围，也就是查找不必从索引为 `0` 的位置开始。`find` 和 `index` 方法还有逆向查找（从后向前查找）的版本，分别是 `rfind` 和 `rindex`，代码如下所示。

```Python
s = 'hello good world!'

# 从前向后查找字符o出现的位置(相当于第一次出现)
print(s.find('o'))       # 4
# 从索引为5的位置开始查找字符o出现的位置
print(s.find('o', 5))    # 7
# 从后向前查找字符o出现的位置(相当于最后一次出现)
print(s.rfind('o'))      # 12
```

### 性质判断

可以通过字符串的 `startswith`、`endswith` 来判断字符串是否以某个字符串开头和结尾；还可以用 `is` 开头的方法判断字符串的特征，这些方法都返回布尔值，代码如下所示。

```Python
s1 = 'hello, world!'

# startwith方法检查字符串是否以指定的字符串开头返回布尔值
print(s1.startswith('He'))    # False
print(s1.startswith('hel'))   # True
# endswith方法检查字符串是否以指定的字符串结尾返回布尔值
print(s1.endswith('!'))       # True

s2 = 'abc123456'

# isdigit方法检查字符串是否由数字构成返回布尔值
print(s2.isdigit())    # False
# isalpha方法检查字符串是否以字母构成返回布尔值
print(s2.isalpha())    # False
# isalnum方法检查字符串是否以数字和字母构成返回布尔值
print(s2.isalnum())    # True
```

### 格式化字符串

在 Python 中，字符串类型可以通过 `center`、`ljust`、`rjust` 方法做居中、左对齐和右对齐的处理。如果要在字符串的左侧补零，也可以使用 `zfill` 方法。

```Python
s = 'hello, world'

# center方法以宽度20将字符串居中并在两侧填充*
print(s.center(20, '*'))  # ****hello, world****
# rjust方法以宽度20将字符串右对齐并在左侧填充空格
print(s.rjust(20))        #         hello, world
# ljust方法以宽度20将字符串左对齐并在右侧填充~
print(s.ljust(20, '~'))   # hello, world~~~~~~~~
# 在字符串的左侧补零
print('33'.zfill(5))      # 00033
print('-33'.zfill(5))     # -0033
```

我们之前讲过，在用 `print` 函数输出字符串时，可以用下面的方式对字符串进行格式化。

```Python
a = 321
b = 123
print('%d * %d = %d' % (a, b, a * b))
```

当然，我们也可以用字符串的方法来完成字符串的格式，代码如下所示。

```Python
a = 321
b = 123
print('{0} * {1} = {2}'.format(a, b, a * b))
```

从 Python 3.6 开始，格式化字符串还有更为简洁的书写方式，就是在字符串前加上 `f` 来格式化字符串，在这种以 `f` 打头的字符串中，`{变量名}` 是一个占位符，会被变量对应的值将其替换掉，代码如下所示。

```Python
a = 321
b = 123
print(f'{a} * {b} = {a * b}')
```

如果需要进一步控制格式化语法中变量值的形式，可以参照下面的表格来进行字符串格式化操作。

| 变量值      | 占位符     | 格式化结果      | 说明                   |
| ----------- | ---------- | --------------- | ---------------------- |
| `3.1415926` | `{:.2f}`   | `'3.14'`        | 保留小数点后两位       |
| `3.1415926` | `{:+.2f}`  | `'+3.14'`       | 带符号保留小数点后两位 |
| `-1`        | `{:+.2f}`  | `'-1.00'`       | 带符号保留小数点后两位 |
| `3.1415926` | `{:.0f}`   | `'3'`           | 不带小数               |
| `123`       | `{:0>10d}` | `'0000000123'`  | 左边补 `0`，补够 10 位    |
| `123`       | `{:x<10d}` | `'123xxxxxxx'`  | 右边补 `x` ，补够 10 位   |
| `123`       | `{:>10d}`  | `'       123'`  | 左边补空格，补够 10 位   |
| `123`       | `{:<10d}`  | `'123       '`  | 右边补空格，补够 10 位   |
| `123456789` | `{:,}`     | `'123,456,789'` | 逗号分隔格式           |
| `0.123`     | `{:.2%}`   | `'12.30%'`      | 百分比格式             |
| `123456789` | `{:.2e}`   | `'1.23e+08'`    | 科学计数法格式         |

### 修剪操作

字符串的 `strip` 方法可以帮我们获得将原字符串修剪掉左右两端空格之后的字符串。这个方法非常有实用价值，通常用来将用户输入中因为不小心键入的头尾空格去掉，`strip` 方法还有 `lstrip` 和 `rstrip` 两个版本，相信从名字大家已经猜出来这两个方法是做什么用的。

```Python
s = '   jackfrued@126.com  \t\r\n'
# strip方法获得字符串修剪左右两侧空格之后的字符串
print(s.strip())    # jackfrued@126.com
```

### 替换操作

如果希望用新的内容替换字符串中指定的内容，可以使用 `replace` 方法，代码如下所示。`replace` 方法的第一个参数是被替换的内容，第二个参数是替换后的内容，还可以通过第三个参数指定替换的次数。

```Python
s = 'hello, world'
print(s.replace('o', '@'))     # hell@, w@rld
print(s.replace('o', '@', 1))  # hell@, world
```

### 拆分/合并操作

可以使用字符串的 `split` 方法将一个字符串拆分为多个字符串（放在一个列表中），也可以使用字符串的 `join` 方法将列表中的多个字符串连接成一个字符串，代码如下所示。

```Python
s = 'I love you'
words = s.split()

print(words)            # ['I', 'love', 'you']
print('#'.join(words))  # I#love#you
```

需要说明的是，`split` 方法默认使用空格进行拆分，我们也可以指定其他的字符来拆分字符串，而且还可以指定最大拆分次数来控制拆分的效果，代码如下所示。

```Python
s = 'I#love#you#so#much'
words = s.split('#')
print(words)  # ['I', 'love', 'you', 'so', 'much']
words = s.split('#', 3)
print(words)  # ['I', 'love', 'you', 'so#much']
```

### 编码/解码操作

Python 中除了字符串 `str` 类型外，还有一种表示二进制数据的字节串类型（`bytes`）。所谓字节串，就是**由零个或多个字节组成的有限序列**。通过字符串的 `encode` 方法，我们可以按照某种编码方式将字符串编码为字节串，我们也可以使用字节串的 `decode` 方法，将字节串解码为字符串，代码如下所示。

```Python
a = '张三'
b = a.encode('utf-8')
c = a.encode('gbk')
print(b, c)  # b'\xe5\xbc\xa0\xe4\xb8\x89' b'\xd5\xc5\xc8\xfd'
print(b.decode('utf-8'))
print(c.decode('gbk'))
```

注意，如果编码和解码的方式不一致，会导致乱码问题（无法再现原始的内容）或引发 `UnicodeDecodeError` 错误导致程序崩溃。

### 其他方法

对于字符串类型来说，还有一个常用的操作是对字符串进行匹配检查，即检查字符串是否满足某种特定的模式。例如，一个网站对用户注册信息中用户名和邮箱的检查，就属于模式匹配检查。实现模式匹配检查的工具叫做正则表达式，Python 语言通过标准库中的 `re` 模块提供了对正则表达式的支持，我们会在后续的课程中为大家讲解这个知识点。



# 数据结构之列表


Python 中的列表底层是一个可以动态扩容的数组，列表元素在内存中也是连续存储的，所以可以实现随机访问（通过一个有效的索引获取到对应的元素且操作时间与列表元素个数无关）。我们暂时不去触碰这些底层存储细节以及列表每个方法的渐近时间复杂度（执行这个方法耗费的时间跟列表元素个数的关系），等需要的时候再告诉大家。现阶段，大家只需要知道**列表是容器**，可以**保存各种类型的数据**，**可以通过索引操作列表元素**，知道这些就足够了。

## 定义和使用列表

在 Python 中，**列表是由一系元素按特定顺序构成的数据序列**，这样就意味着定义一个列表类型的变量，**可以保存多个数据**，而且**允许有重复的数据**。跟上一课我们讲到的字符串类型一样，列表也是一种结构化的、非标量类型，操作一个列表类型的变量，除了可以使用运算符还可以使用它的方法。

在 Python 中，可以使用 `[]` 字面量语法来定义列表，列表中的多个元素用逗号进行分隔，代码如下所示。

```Python
items1 = [35, 12, 99, 68, 55, 87]
items2 = ['Python', 'Java', 'Go', 'Kotlin']
```

除此以外，还可以通过 Python 内置的 `list` 函数将其他序列变成列表。准确的说，`list` 并不是一个普通的函数，它是创建列表对象的构造器（后面会讲到对象和构造器这两个概念）。

```Python
items1 = list(range(1, 10))
print(items1)    # [1, 2, 3, 4, 5, 6, 7, 8, 9]
items2 = list('hello')
print(items2)    # ['h', 'e', 'l', 'l', 'o']
```

需要说明的是，列表是一种可变数据类型，也就是说列表可以添加元素、删除元素、更新元素，这一点跟讲到的字符串有着鲜明的差别。字符串是一种不可变数据类型，也就是说对字符串做拼接、重复、转换大小写、修剪空格等操作的时候会产生新的字符串，原来的字符串并没有发生任何改变。

## 列表的运算符

和字符串类型一样，列表也支持拼接、重复、成员运算、索引和切片以及比较运算，对此我们不再进行赘述，请大家参考下面的代码。

```Python
items1 = [35, 12, 99, 68, 55, 87]
items2 = [45, 8, 29]

# 列表的拼接
items3 = items1 + items2
print(items3)    # [35, 12, 99, 68, 55, 87, 45, 8, 29]

# 列表的重复
items4 = ['hello'] * 3
print(items4)    # ['hello', 'hello', 'hello']

# 列表的成员运算
print(100 in items3)        # False
print('hello' in items4)    # True

# 获取列表的长度(元素个数)
size = len(items3)
print(size)                 # 9

# 列表的索引
print(items3[0], items3[-size])        # 35 35
items3[-1] = 100
print(items3[size - 1], items3[-1])    # 100 100

# 列表的切片
print(items3[:5])          # [35, 12, 99, 68, 55]
print(items3[4:])          # [55, 87, 45, 8, 100]
print(items3[-5:-7:-1])    # [55, 68]
print(items3[::-2])        # [100, 45, 55, 99, 35]

# 列表的比较运算
items5 = [1, 2, 3, 4]
items6 = list(range(1, 5)) # 左闭右开 [,)
# 两个列表比较相等性比的是对应索引位置上的元素是否相等
print(items5 == items6)    # True
items7 = [3, 2, 1]
# 两个列表比较大小比的是对应索引位置上的元素的大小
print(items5 <= items7)    # True
```

值得一提的是，由于列表是可变类型，所以**通过索引操作既可以获取列表中的元素，也可以更新列表中的元素**。对列表做索引操作一样要注意索引越界的问题，对于有 `N` 个元素的列表，正向索引的范围是 `0` 到 `N-1`，负向索引的范围是 `-1` 到 `-N`，如果超出这个范围，将引发 `IndexError` 异常，错误信息为：`list index out of range`。

## 列表元素的遍历

如果想逐个取出列表中的元素，可以使用 `for` 循环的，有以下两种做法。

方法一：

```Python
items = ['Python', 'Java', 'Go', 'Kotlin']

for index in range(len(items)):
    print(items[index])
```

方法二：

```Python
items = ['Python', 'Java', 'Go', 'Kotlin']

for item in items:
    print(item)
```

讲到这里，我们可以用列表的知识来重构上面“掷色子统计每个点数出现次数”的代码。

```Python
import random

counters = [0] * 6
# _只是用于补位，不做实际用途
for _ in range(6000):
    face = random.randint(1, 6)
    counters[face - 1] += 1
for face in range(1, 7):
    print(f'{face}点出现了{counters[face - 1]}次')
```

上面的代码中，我们用 `counters` 列表中的六个元素分别表示 1 到 6 的点数出现的次数，最开始的时候六个元素的值都是 `0`。接下来用随机数模拟掷色子，如果摇出 1 点 `counters[0]` 的值加 `1`，如果摇出 2 点 `counters[1]` 的值加 `1`，以此类推。大家感受一下，这段代码是不是比之前的代码要简单优雅很多。

## 列表的方法

和字符串一样，列表类型的方法也很多，下面为大家讲解比较重要的方法。

### 添加和删除元素

```Python
items = ['Python', 'Java', 'Go', 'Kotlin']

# 使用append方法在列表尾部添加元素
items.append('Swift')
print(items)    # ['Python', 'Java', 'Go', 'Kotlin', 'Swift']
# 使用insert方法在列表指定索引位置插入元素
items.insert(2, 'SQL')
print(items)    # ['Python', 'Java', 'SQL', 'Go', 'Kotlin', 'Swift']

# 删除指定的元素（value值）
items.remove('Java')
print(items)    # ['Python', 'SQL', 'Go', 'Kotlin', 'Swift']
# 删除指定索引位置的元素
items.pop(0)
items.pop(len(items) - 1)
print(items)    # ['SQL', 'Go', 'Kotlin']

# 清空列表中的元素
items.clear()
print(items)    # []
```

需要提醒大家，在使用 `remove` 方法删除元素时，如果要删除的元素并不在列表中，会引发 `ValueError` 异常，错误消息是：`list.remove(x): x not in list`。在使用 `pop` 方法删除元素时，如果索引的值超出了范围，会引发 `IndexError` 异常，错误消息是：`pop index out of range`。

从列表中删除元素其实还有一种方式，就是使用 Python 中的 `del` 关键字后面跟要删除的元素，这种做法跟使用 `pop` 方法指定索引删除元素没有实质性的区别，但后者会返回删除的元素，前者在性能上略优（`del` 对应字节码指令是 `DELETE_SUBSCR`，而 `pop` 对应的字节码指令是 `CALL_METHOD` 和 `POP_TOP`，不理解就跳过，不用管它！！！）。

```Python
items = ['Python', 'Java', 'Go', 'Kotlin']
del items[1]
print (items)    # ['Python', 'Go', 'Kotlin']
```

### 元素位置和次数

列表类型的`index`方法可以查找某个元素在列表中的索引位置；因为列表中允许有重复的元素，所以列表类型提供了`count`方法来统计一个元素在列表中出现的次数。请看下面的代码。

```Python
items = ['Python', 'Java', 'Java', 'Go', 'Kotlin', 'Python']

# 查找元素的索引位置
print (items.index ('Python'))       # 0
print (items.index ('Python', 2))    # 5
# 注意：虽然列表中有'Java'，但是从索引为 3 这个位置开始后面是没有'Java'的
print (items.index ('Java', 3))      # ValueError: 'Java' is not in list
```

再来看看下面这段代码。

```Python
items = ['Python', 'Java', 'Java', 'Go', 'Kotlin', 'Python']

# 查找元素出现的次数
print (items.count ('Python'))    # 2
print (items.count ('Go'))        # 1
print (items.count ('Swfit'))     # 0
```

### 元素排序和反转

列表的`sort`操作可以实现列表元素的排序，而`reverse`操作可以实现元素的反转，代码如下所示。

```Python
items = ['Python', 'Java', 'Go', 'Kotlin', 'Python']

# 排序
items.sort ()
print (items)    # ['Go', 'Java', 'Kotlin', 'Python', 'Python']
# 反转
items.reverse ()
print (items)    # ['Python', 'Python', 'Kotlin', 'Java', 'Go']
```

### 列表的生成式

在 Python 中，列表还可以通过一种特殊的字面量语法来创建，这种语法叫做生成式。我们给出两段代码，大家可以做一个对比，看看哪一种方式更加简单优雅。

通过`for`循环为空列表添加元素。

```Python
# 创建一个由 1 到 9 的数字构成的列表
items 1 = []
for x in range (1, 10):
    items 1.append (x)
print (items 1)

# 创建一个由'hello world'中除空格和元音字母外的字符构成的列表
items 2 = []
for x in 'hello world':
    if x not in ' aeiou':
        items 2.append (x)
print (items 2)

# 创建一个由个两个字符串中字符的笛卡尔积构成的列表
items 3 = []
for x in 'ABC':
    for y in '12':
        items 3.append (x + y)
print (items 3)
```

通过生成式创建列表。

```Python
# 创建一个由 1 到 9 的数字构成的列表
items 1 = [x for x in range (1, 10)]
print (items 1)    # [1, 2, 3, 4, 5, 6, 7, 8, 9]

# 创建一个由'hello world'中除空格和元音字母外的字符构成的列表
items 2 = [x for x in 'hello world' if x not in ' aeiou']
print (items 2)    # ['h', 'l', 'l', 'w', 'r', 'l', 'd']

# 创建一个由个两个字符串中字符的笛卡尔积构成的列表
items 3 = [x + y for x in 'ABC' for y in '12']
print (items 3)    # ['A 1', 'A 2', 'B 1', 'B 2', 'C 1', 'C 2']
```

下面这种方式不仅代码简单优雅，而且性能也优于上面使用`for`循环和`append`方法向空列表中追加元素的方式。可以简单跟大家交待下为什么生成式拥有更好的性能，那是因为 Python 解释器的字节码指令中有专门针对生成式的指令（`LIST_APPEND`指令）；而`for`循环是通过方法调用（`LOAD_METHOD`和`CALL_METHOD`指令）的方式为列表添加元素，方法调用本身就是一个相对耗时的操作。对这一点不理解也没有关系，记住“**强烈建议用生成式语法来创建列表**”这个结论就可以了。

### 嵌套的列表

Python 语言没有限定列表中的元素必须是相同的数据类型，也就是说一个列表中的元素可以任意的数据类型，当然也包括列表。如果列表中的元素又是列表，那么我们可以称之为嵌套的列表。嵌套的列表可以用来表示表格或数学上的矩阵，例如：我们想保存 5 个学生 3 门课程的成绩，可以定义一个保存 5 个元素的列表保存 5 个学生的信息，而每个列表元素又是 3 个元素构成的列表，分别代表 3 门课程的成绩。但是，一定要注意下面的代码是有问题的。

```Python
scores = [[0] * 3] * 5
print (scores)    # [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
```

看上去我们好像创建了一个`5 * 3`的嵌套列表，但实际上当我们录入第一个学生的第一门成绩后，你就会发现问题来了，我们看看下面代码的输出。

```Python
# 嵌套的列表需要多次索引操作才能获取元素
scores[0][0] = 95
print (scores)
# [[95, 0, 0], [95, 0, 0], [95, 0, 0], [95, 0, 0], [95, 0, 0]]
```

我们不去过多的解释为什么会出现这样的问题，如果想深入研究这个问题，可以通过 [Python Tutor](<http://www.pythontutor.com/visualize.html>) 网站的可视化代码执行功能，看看创建列表时计算机内存中发生了怎样的变化，下面的图就是在这个网站上生成的。建议大家不去纠结这个问题，现阶段只需要记住不能用`[[0] * 3] * 5]`这种方式来创建嵌套列表就行了。那么创建嵌套列表的正确做法是什么呢，下面的代码会给你答案。

```Python
scores = [[0] * 3 for _ in range (5)]
scores[0][0] = 95
print (scores)
# [[95, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]]
```



# 数据结构之元组

**列表和元组都是容器型的数据类型**，即一个变量可以保存多个数据。**列表是可变数据类型**，**元组是不可变数据类型**，所以列表添加元素、删除元素、清空、排序等方法对于元组来说是不成立的。但是列表和元组都可以进行**拼接**、**成员运算**、**索引和切片**这些操作，后面我们要讲到的字符串类型也是这样，因为字符串就是字符按一定顺序构成的序列，在这一点上三者并没有什么区别。我们**推荐大家使用列表的生成式语法来创建列表**，它很好用，也是 Python 中非常有特色的语法。

## 定义和使用元组

在 Python 中，元组也是多个元素按照一定的顺序构成的序列。元组和列表的不同之处在于，**元组是不可变类型，这就意味着元组类型的变量一旦定义，其中的元素不能再添加或删除，而且元素的值也不能进行修改**。定义元组通常使用 `()` 字面量语法，也建议大家使用这种方式来创建元组。元组类型支持的运算符跟列表是一样。下面的代码演示了元组的定义和运算。

```Python
# 定义一个三元组
t1 = (30, 10, 55)
# 定义一个四元组
t2 = ('Ellen', 18, True, '四川成都')

# 查看变量的类型
print(type(t1), type(t2))    # <class 'tuple'> <class 'tuple'>
# 查看元组中元素的数量
print(len(t1), len(t2))      # 3 4

# 通过索引运算获取元组中的元素
print(t1[0], t1[-3])         # 30 30
print(t2[3], t2[-1])         # 四川成都 四川成都

# 循环遍历元组中的元素
for member in t2:
    print(member)

# 成员运算
print(100 in t1)    # False
print(40 in t2)     # True

# 拼接
t3 = t1 + t2
print(t3)           # (30, 10, 55, 'Ellen', 18, True, '四川成都')

# 切片
print(t3[::3])      # (30, '骆昊', '四川成都')

# 比较运算
print(t1 == t3)    # False
print(t1 >= t3)    # False
print(t1 < (30, 11, 55))    # True
```

一个元组中如果有两个元素，我们就称之为二元组；一个元组中如果五个元素，我们就称之为五元组。需要提醒大家注意的是，`()` 表示空元组，但是如果元组中只有一个元素，需要加上一个逗号，否则 `()` 就不是代表元组的字面量语法，而是改变运算优先级的圆括号，所以 `('hello', )` 和 `(100, )` 才是一元组，而 `('hello')` 和 `(100)` 只是字符串和整数。我们可以通过下面的代码来加以验证。

```Python
# 空元组
a = ()
print(type(a))    # <class 'tuple'>
# 不是元组
b = ('hello')
print(type(b))    # <class 'str'>
c = (100)
print(type(c))    # <class 'int'>
# 一元组
d = ('hello', )
print(type(d))    # <class 'tuple'>
e = (100, )
print(type(e))    # <class 'tuple'>
```

## 元组的应用场景

### 例1：打包和解包操作

当我们把多个用逗号分隔的值赋给一个变量时，多个值会打包成一个元组类型；当我们把一个元组赋值给多个变量时，元组会解包成多个值然后分别赋给对应的变量，如下面的代码所示。

```Python
# 打包
a = 1, 10, 100
print(type(a), a)    # <class 'tuple'> (1, 10, 100)
# 解包
i, j, k = a
print(i, j, k)       # 1 10 100
```

在解包时，如果解包出来的元素个数和变量个数不对应，会引发 `ValueError` 异常，错误信息为：`too many values to unpack`（解包的值太多）或 `not enough values to unpack`（解包的值不足）。

```Python
a = 1, 10, 100, 1000
# i, j, k = a             # ValueError: too many values to unpack (expected 3)
# i, j, k, l, m, n = a    # ValueError: not enough values to unpack (expected 6, got 4)
```

有一种解决变量个数少于元素的个数方法，就是使用星号表达式，我们之前讲函数的可变参数时使用过星号表达式。有了星号表达式，我们就可以让一个变量接收多个值，代码如下所示。需要注意的是，用星号表达式修饰的变量会变成一个列表，列表中有 0 个或多个元素。还有在解包语法中，星号表达式只能出现一次。

```Python
a = 1, 10, 100, 1000
i, j, *k = a
print(i, j, k)          # 1 10 [100, 1000]

i, *j, k = a
print(i, j, k)          # 1 [10, 100] 1000

*i, j, k = a
print(i, j, k)          # [1, 10] 100 1000

*i, j = a
print(i, j)             # [1, 10, 100] 1000

i, *j = a
print(i, j)             # 1 [10, 100, 1000]

i, j, k, *l = a
print(i, j, k, l)       # 1 10 100 [1000]

i, j, k, l, *m = a
print(i, j, k, l, m)    # 1 10 100 1000 []
```

需要说明一点，解包语法对所有的序列都成立，这就意味着对列表以及我们之前讲到的 `range` 函数返回的范围序列都可以使用解包语法。大家可以尝试运行下面的代码，看看会出现怎样的结果。

```Python
a, b, *c = range(1, 10)
print(a, b, c)

a, b, c = [1, 10, 100]
print(a, b, c)

a, *b, c = 'hello'
print(a, b, c)
```

### 例2：交换两个变量的值

交换两个变量的值是编程语言中的一个经典案例，在很多编程语言中，交换两个变量的值都需要借助一个中间变量才能做到，如果不用中间变量就需要使用比较晦涩的位运算来实现。在 Python 中，交换两个变量 `a` 和 `b` 的值只需要使用如下所示的代码。

```Python
a, b = b, a
```

同理，如果要将三个变量 `a`、`b`、`c` 的值互换，即 `b` 赋给 `a`，`c` 赋给 `b`，`a` 赋给 `c`，也可以如法炮制。

```Python
a, b, c = b, c, a
```

需要说明的是，上面并没有用到打包和解包语法，Python 的字节码指令中有 `ROT_TWO` 和 `ROT_THREE` 这样的指令可以实现这个操作，效率是非常高的。但是如果有多于三个变量的值要依次互换，这个时候没有直接可用的字节码指令，执行的原理就是我们上面讲解的打包和解包操作。

## 元组和列表的比较

这里还有一个非常值得探讨的问题，Python 中已经有了列表类型，为什么还需要元组这样的类型呢？这个问题对于初学者来说似乎有点困难，不过没有关系，我们先抛出观点，大家可以一边学习一边慢慢体会。

1. 元组是不可变类型，**不可变类型更适合多线程环境**，因为它降低了并发访问变量的同步化开销。关于这一点，我们会在后面讲解多线程的时候为大家详细论述。

2. 元组是不可变类型，通常**不可变类型在创建时间和占用空间上面都优于对应的可变类型**。我们可以使用 `sys` 模块的 `getsizeof` 函数来检查保存相同元素的元组和列表各自占用了多少内存空间。我们也可以使用 `timeit` 模块的 `timeit` 函数来看看创建保存相同元素的元组和列表各自花费的时间，代码如下所示。

   ```Python
   import sys
   import timeit
   
   a = list(range(100000))
   b = tuple(range(100000))
   print(sys.getsizeof(a), sys.getsizeof(b))    # 900120 800056
   
   print(timeit.timeit('[1, 2, 3, 4, 5, 6, 7, 8, 9]'))
   print(timeit.timeit('(1, 2, 3, 4, 5, 6, 7, 8, 9)'))
   ```

3. Python 中的元组和列表是可以相互转换的，我们可以通过下面的代码来做到。

   ```Python
   # 将元组转换成列表
   info = ('Ellen', 175, True, '四川成都')
   print(list(info))       # ['Ellen', 175, True, '四川成都']
   
   # 将列表转换成元组
   fruits = ['apple', 'banana', 'orange']
   print(tuple(fruits))    # ('apple', 'banana', 'orange')
   ```



# 数据结构之集合

在学习了列表和元组之后，我们再来学习一种容器型的数据类型，它的名字叫集合（set）。说到集合这个词大家一定不会陌生，在数学课本上就有这个概念。通常我们对集合的定义是“**把一定范围的、确定的、可以区别的事物当作一个整体来看待**”，集合中的各个事物通常称为集合的**元素**。集合应该满足以下特性：

1. **无序性**：一个集合中，每个元素的地位都是相同的，元素之间是无序的。
2. **互异性**：一个集合中，任何两个元素都是不相同的，即元素在集合中只能出现一次。
3. **确定性**：给定一个集合和一个任意元素，该元素要么属这个集合，要么不属于这个集合，二者必居其一，不允许有模棱两可的情况出现。

Python 程序中的集合跟数学上的集合是完全一致的，需要强调的是上面所说的无序性和互异性。无序性说明集合中的元素并不像列中的元素那样一个挨着一个，可以通过索引实现随机访问（随机访问指的是给定一个有效的范围，随机抽取出一个数字，然后通过这个数字可以获取到对应的元素），所以 Python 中的**集合肯定不能够支持索引运算**。另外，集合的互异性决定了**集合中不能有重复元素**，这一点也是集合区别于列表的关键，说得更直白一些就是，Python 中的集合类型会对其中的元素做去重处理。Python 中的集合一定是支持 `in` 和 `not in` 成员运算的，这样就可以确定一个元素是否属于集合，也就是上面所说的集合的确定性。**集合的成员运算在性能上要优于列表的成员运算**，这是集合的底层存储特性（哈希存储）决定的，此处我们暂时不做讨论，大家可以先记下这个结论。

Python 中的集合底层使用了**哈希存储**的方式，对于这一点我们暂时不做介绍，在后面的课程有需要的时候再为大家讲解集合的底层原理，现阶段大家只需要知道**集合是一种容器**，元素必须是 `hashable` 类型，与列表不同的地方在于集合中的元素**没有序**、**不能用索引运算**、**不能重复**。

## 创建集合

在 Python 中，创建集合可以使用 `{}` 字面量语法，`{}` 中需要至少有一个元素，因为没有元素的 `{}` 并不是空集合而是一个空字典，我们下一节课就会大家介绍字典的知识。当然，也可以使用内置函数 `set` 来创建一个集合，准确的说 `set` 并不是一个函数，而是创建集合对象的构造器，这个知识点我们很快也会讲到，现在不理解跳过它就可以了。要创建空集合可以使用 `set()`；也可以将其他序列转换成集合，例如：`set('hello')` 会得到一个包含了 4 个字符的集合（重复的 `l` 会被去掉）。除了这两种方式，我们还可以使用生成式语法来创建集合，就像我们之前用生成式创建列表那样。要知道集合中有多少个元素，还是使用内置函数 `len`；使用 `for` 循环可以实现对集合元素的遍历。

```Python
# 创建集合的字面量语法(重复元素不会出现在集合中)
set1 = {1, 2, 3, 3, 3, 2}
print(set1)         # {1, 2, 3}
print(len(set1))    # 3

# 创建集合的构造器语法(后面会讲到什么是构造器)
set2 = set('hello')
print(set2)         # {'h', 'l', 'o', 'e'}

# 将列表转换成集合(可以去掉列表中的重复元素)
set3 = set([1, 2, 3, 3, 2, 1])
print(set3)         # {1, 2, 3}

# 创建集合的生成式语法(将列表生成式的[]换成{})
set4 = {num for num in range(1, 20) if num % 3 == 0 or num % 5 == 0}
print(set4)         # {3, 5, 6, 9, 10, 12, 15, 18}

# 集合元素的循环遍历
for elem in set4:
    print(elem)
```

需要提醒大家，集合中的元素必须是 `hashable` 类型。所谓 `hashable` 类型指的是能够计算出哈希码的数据类型，大家可以暂时将哈希码理解为和变量对应的唯一的 ID 值。通常不可变类型都是 `hashable` 类型，如整数、浮点、字符串、元组等，而可变类型都不是 `hashable` 类型，因为可变类型无法确定唯一的 ID 值，所以也就不能放到集合中。**集合本身也是可变类型，所以集合不能够作为集合中的元素**，这一点在使用集合的时候一定要注意。

## 集合的运算

Python 为集合类型提供了非常丰富的运算符，主要包括：成员运算、交集运算、并集运算、差集运算、比较运算（相等性、子集、超集）等。

### 成员运算

可以通过成员运算 `in` 和 `not in ` 检查元素是否在集合中，代码如下所示。

```Python
set1 = {11, 12, 13, 14, 15}
print(10 in set1)        # False 
print(15 in set1)        # True
set2 = {'Python', 'Java', 'Go', 'Swift'}
print('Ruby' in set2)    # False
print('Java' in set2)    # True
```

### 交并差运算

Python 中的集合跟数学上的集合一样，可以进行交集、并集、差集等运算，而且可以通过运算符和方法调用两种方式来进行操作，代码如下所示。

```Python
set1 = {1, 2, 3, 4, 5, 6, 7}
set2 = {2, 4, 6, 8, 10}

# 交集
# 方法一: 使用 & 运算符
print(set1 & set2)                # {2, 4, 6}
# 方法二: 使用intersection方法
print(set1.intersection(set2))    # {2, 4, 6}

# 并集
# 方法一: 使用 | 运算符
print(set1 | set2)         # {1, 2, 3, 4, 5, 6, 7, 8, 10}
# 方法二: 使用union方法
print(set1.union(set2))    # {1, 2, 3, 4, 5, 6, 7, 8, 10}

# 差集
# 方法一: 使用 - 运算符
print(set1 - set2)              # {1, 3, 5, 7}
# 方法二: 使用difference方法
print(set1.difference(set2))    # {1, 3, 5, 7}

# 对称差
# 方法一: 使用 ^ 运算符
print(set1 ^ set2)                        # {1, 3, 5, 7, 8, 10}
# 方法二: 使用symmetric_difference方法
print(set1.symmetric_difference(set2))    # {1, 3, 5, 7, 8, 10}
# 方法三: 对称差相当于两个集合的并集减去交集
print((set1 | set2) - (set1 & set2))      # {1, 3, 5, 7, 8, 10}
```

通过上面的代码可以看出，对两个集合求交集，`&` 运算符和 `intersection` 方法的作用是完全相同的，使用运算符的方式更直观而且代码也比较简短。相信大家对交集、并集、差集、对称差这几个概念是比较清楚的，如果没什么印象了可以看看下面的图。

![[20240612193501.png|550]]

集合的交集、并集、差集运算还可以跟赋值运算一起构成复合赋值运算，如下所示。

```Python
set1 = {1, 3, 5, 7}
set2 = {2, 4, 6}
# 将set1和set2求并集再赋值给set1
# 也可以通过set1.update(set2)来实现
set1 |= set2
print(set1)    # {1, 2, 3, 4, 5, 6, 7}
set3 = {3, 6, 9}
# 将set1和set3求交集再赋值给set1
# 也可以通过set1.intersection_update(set3)来实现
set1 &= set3
print(set1)    # {3, 6}
```

### 比较运算

两个集合可以用 `==` 和 `!=` 进行相等性判断，如果两个集合中的元素完全相同，那么 `==` 比较的结果就是 `True`，否则就是 `False`。如果集合 `A` 的任意一个元素都是集合 `B` 的元素，那么集合 `A` 称为集合 `B` 的子集，即对于$ \forall{a} \in {A}$，均有$ {a} \in {B} $，则$ {A} \subseteq {B} $，`A` 是 `B` 的子集，反过来也可以称 `B` 是 `A` 的超集。如果 `A` 是 `B` 的子集且 `A` 不等于 `B`，那么 `A` 就是 `B` 的真子集。Python 为集合类型提供了判断子集和超集的运算符，其实就是我们非常熟悉的 `<` 和 `>` 运算符，代码如下所示。

```Python
set1 = {1, 3, 5}
set2 = {1, 2, 3, 4, 5}
set3 = set2
# <运算符表示真子集，<=运算符表示子集
print(set1 < set2, set1 <= set2)    # True True
print(set2 < set3, set2 <= set3)    # False True
# 通过issubset方法也能进行子集判断
print(set1.issubset(set2))      # True

# 反过来可以用issuperset或>运算符进行超集判断
print(set2.issuperset(set1))    # True
print(set2 > set1)              # True
```


## 集合的方法

Python 中的集合是可变类型，我们可以通过集合类型的方法为集合添加或删除元素。

```Python
# 创建一个空集合
set1 = set()

# 通过add方法添加元素
set1.add(33)
set1.add(55)
set1.update({1, 10, 100, 1000})
print(set1)    # {33, 1, 100, 55, 1000, 10}

# 通过discard方法删除指定元素
set1.discard(100)
set1.discard(99)
print(set1)    # {1, 10, 33, 55, 1000}

# 通过remove方法删除指定元素，建议先做成员运算再删除
# 否则元素如果不在集合中就会引发KeyError异常
if 10 in set1:
    set1.remove(10)
print(set1)    # {33, 1, 55, 1000}

# pop方法可以从集合中随机删除一个元素并返回该元素
print(set1.pop())

# clear方法可以清空整个集合
set1.clear()

print(set1)    # set()
```

如果要判断两个集合有没有相同的元素可以使用 `isdisjoint` 方法，没有相同元素返回 `True`，否则返回 `False`，代码如下所示。

```Python
set1 = {'Java', 'Python', 'Go', 'Kotlin'}
set2 = {'Kotlin', 'Swift', 'Java', 'Objective-C', 'Dart'}
set3 = {'HTML', 'CSS', 'JavaScript'}
print(set1.isdisjoint(set2))    # False
print(set1.isdisjoint(set3))    # True
```

## 不可变集合

Python 中还有一种不可变类型的集合，名字叫 `frozenset`。`set` 跟 `frozenset` 的区别就如同 `list` 跟 `tuple` 的区别，`frozenset` 由于是不可变类型，能够计算出哈希码，因此它可以作为 `set` 中的元素。除了不能添加和删除元素，`frozenset` 在其他方面跟 `set` 基本是一样的，下面的代码简单的展示了 `frozenset` 的用法。

```Python
set1 = frozenset({1, 3, 5, 7})
set2 = frozenset(range(1, 6))
print(set1 & set2)    # frozenset({1, 3, 5})
print(set1 | set2)    # frozenset({1, 2, 3, 4, 5, 7})
print(set1 - set2)    # frozenset({7})
print(set1 < set2)    # False
```


# 数据结构之字典

迄今为止，我们已经为大家介绍了 Python 中的三种容器型数据类型，但是这些数据类型仍然不足以帮助我们解决所有的问题。例如，我们要保存一个人的信息，包括姓名、年龄、体重、单位地址、家庭住址、本人手机号、紧急联系人手机号等信息，你会发现我们之前学过的列表、元组和集合都不是最理想的选择。

```Python
person1 = ['王大锤', 55, 60, '科华北路62号', '中同仁路8号', '13122334455', '13800998877']
person2 = ('王大锤', 55, 60, '科华北路62号', '中同仁路8号', '13122334455', '13800998877')
person3 = {'王大锤', 55, 60, '科华北路62号', '中同仁路8号', '13122334455', '13800998877'}
```

集合肯定是最不合适的，因为集合有去重特性，如果一个人的年龄和体重相同，那么集合中就会少一项信息；同理，如果这个人的家庭住址和单位地址是相同的，那么集合中又会少一项信息。另一方面，虽然列表和元组可以把一个人的所有信息都保存下来，但是当你想要获取这个人的手机号时，你得先知道他的手机号是列表或元组中的第 6 个还是第 7 个元素；当你想获取一个人的家庭住址时，你还得知道家庭住址是列表或元组中的第几项。总之，在遇到上述的场景时，列表、元组、字典都不是最合适的选择，我们还需字典（dictionary）类型，这种数据类型最适合把相关联的信息组装到一起，并且可以帮助我们解决程序中为真实事物建模的问题。

Python 程序中的字典跟现实生活中的字典很像，它以键值对（键和值的组合）的方式把数据组织到一起，我们可以通过键找到与之对应的值并进行操作。就像《新华字典》中，每个字（键）都有与它对应的解释（值）一样，每个字和它的解释合在一起就是字典中的一个条目，而字典中通常包含了很多个这样的条目。

Python 程序中的字典跟现实生活中字典非常像，允许我们**以键值对的形式保存数据**，再**通过键索引对应的值**。这是一种非常**有利于数据检索**的数据类型，底层原理我们在后续的课程中为大家讲解。再次提醒大家注意，**字典中的键必须是不可变类型**，字典中的值可以是任意类型。
## 创建和使用字典

在 Python 中创建字典可以使用 `{}` 字面量语法，这一点跟上一节课讲的集合是一样的。但是字典的 `{}` 中的元素是以键值对的形式存在的，每个元素由 `:` 分隔的两个值构成，`:` 前面是键，`:` 后面是值，代码如下所示。

```Python
xinhua = {
    '麓': '山脚下',
    '路': '道，往来通行的地方；方面，地区：南～货，外～货；种类：他俩是一～人',
    '蕗': '甘草的别名',
    '潞': '潞水，水名，即今山西省的浊漳河；潞江，水名，即云南省的怒江'
}
print(xinhua)
person = {
    'name': '王大锤', 'age': 55, 'weight': 60, 'office': '科华北路62号',
    'home': '中同仁路8号', 'tel': '13122334455', 'econtact': '13800998877'
}
print(person)
```

通过上面的代码，相信大家已经看出来了，用字典来保存一个人的信息远远优于使用列表或元组，因为我们可以用 `:` 前面的键来表示条目的含义，而 `:` 后面就是这个条目所对应的值。

当然，如果愿意，我们也可以使用内置函数 `dict` 或者是字典的生成式语法来创建字典，代码如下所示。

```Python
# dict函数(构造器)中的每一组参数就是字典中的一组键值对
person = dict(name='王大锤', age=55, weight=60, home='中同仁路8号')
print(person)    # {'name': '王大锤', 'age': 55, 'weight': 60, 'home': '中同仁路8号'}

# 可以通过Python内置函数zip压缩两个序列并创建字典
items1 = dict(zip('ABCDE', '12345'))
print(items1)    # {'A': '1', 'B': '2', 'C': '3', 'D': '4', 'E': '5'}
items2 = dict(zip('ABCDE', range(1, 10)))
print(items2)    # {'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5}

# 用字典生成式语法创建字典
items3 = {x: x ** 3 for x in range(1, 6)}
print(items3)     # {1: 1, 2: 8, 3: 27, 4: 64, 5: 125}
```

想知道字典中一共有多少组键值对，仍然是使用 `len` 函数；如果想对字典进行遍历，可以用 `for` 循环，但是需要注意，`for` 循环只是对字典的键进行了遍历，不过没关系，在讲完字典的运算后，我们可以通过字典的键获取到和这个键对应的值。

```Python
person = {'name': '王大锤', 'age': 55, 'weight': 60, 'office': '科华北路62号'}
print(len(person))    # 4
for key in person:
    print(key)
```

## 字典的运算

对于字典类型来说，成员运算和索引运算肯定是最为重要的，前者可以判定指定的键在不在字典中，后者可以通过键获取对应的值或者向字典中加入新的键值对。值得注意的是，字典的索引不同于列表的索引，列表中的元素因为有属于自己有序号，所以列表的索引是一个整数；字典中因为保存的是键值对，所以字典的索引是键值对中的键，通过索引操作可以修改原来的值或者向字典中存入新的键值对。需要**特别提醒**大家注意的是，**字典中的键必须是不可变类型**，例如整数（`int`）、浮点数（`float`）、字符串（`str`）、元组（`tuple`）等类型的值；显然，列表（`list`）和集合（`set`）是不能作为字典中的键的，当然字典类型本身也不能再作为字典中的键，因为字典也是可变类型，但是字典可以作为字典中的值。关于可变类型不能作为字典中的键的原因，我们在后面的课程中再为大家详细说明。这里，我们先看看下面的代码，了解一下字典的成员运算和索引运算。

```Python
person = {'name': '王大锤', 'age': 55, 'weight': 60, 'office': '科华北路62号'}
# 检查name和tel两个键在不在person字典中
print('name' in person, 'tel' in person)    # True False

# 通过age修将person字典中对应的值修改为25
if 'age' in person:
    person['age'] = 25
    
# 通过索引操作向person字典中存入新的键值对
person['tel'] = '13122334455'
person['signature'] = '你的男朋友是一个盖世垃圾，他会踏着五彩祥云去迎娶你的闺蜜'
print('name' in person, 'tel' in person)    # True True

# 检查person字典中键值对的数量
print(len(person))    # 6
# 对字典的键进行循环并通索引运算获取键对应的值
for key in person:
    print(f'{key}: {person[key]}')
```

 需要注意，在通过索引运算获取字典中的值时，如指定的键没有在字典中，将会引发 `KeyError` 异常。

## 字典的方法

字典类型的方法基本上都跟字典的键值对操作相关，可以通过下面的例子来了解这些方法的使用。例如，我们要用一个字典来保存学生的信息，我们可以使用学生的学号作为字典中的键，通过学号做索引运算就可以得到对应的学生；我们可以把字典的值也做成一个字典，这样就可以用多组键值对分别存储学生的姓名、性别、年龄、籍贯等信息，代码如下所示。

```Python
# 字典中的值又是一个字典(嵌套的字典)
students = {
    1001: {'name': '狄仁杰', 'sex': True, 'age': 22, 'place': '山西大同'},
    1002: {'name': '白元芳', 'sex': True, 'age': 23, 'place': '河北保定'},
    1003: {'name': '武则天', 'sex': False, 'age': 20, 'place': '四川广元'}
}

# 使用get方法通过键获取对应的值，如果取不到不会引发KeyError异常而是返回None或设定的默认值
print(students.get(1002))    # {'name': '白元芳', 'sex': True, 'age': 23, 'place': '河北保定'}
print(students.get(1005))    # None
print(students.get(1005, {'name': '无名氏'}))    # {'name': '无名氏'}

# 获取字典中所有的键
print(students.keys())      # dict_keys([1001, 1002, 1003])
# 获取字典中所有的值
print(students.values())    # dict_values([{...}, {...}, {...}])
# 获取字典中所有的键值对
print(students.items())     # dict_items([(1001, {...}), (1002, {....}), (1003, {...})])
# 对字典中所有的键值对进行循环遍历
for key, value in students.items():
    print(key, '--->', value)

# 使用pop方法通过键删除对应的键值对并返回该值
stu1 = students.pop(1002)
print(stu1)             # {'name': '白元芳', 'sex': True, 'age': 23, 'place': '河北保定'}
print(len(students))    # 2
# stu2 = students.pop(1005)    # KeyError: 1005
stu2 = students.pop(1005, {})
print(stu2)             # {}

# 使用popitem方法删除字典中最后一组键值对并返回对应的二元组
# 如果字典中没有元素，调用该方法将引发KeyError异常
key, value = students.popitem()
print(key, value)    # 1003 {'name': '武则天', 'sex': False, 'age': 20, 'place': '四川广元'}

# 如果这个键在字典中存在，setdefault返回原来与这个键对应的值
# 如果这个键在字典中不存在，向字典中添加键值对，返回第二个参数的值，默认为None
result = students.setdefault(1005, {'name': '方启鹤', 'sex': True})
print(result)        # {'name': '方启鹤', 'sex': True}
print(students)      # {1001: {...}, 1005: {...}}

# 使用update更新字典元素，相同的键会用新值覆盖掉旧值，不同的键会添加到字典中
others = {
    1005: {'name': '乔峰', 'sex': True, 'age': 32, 'place': '北京大兴'},
    1010: {'name': '王语嫣', 'sex': False, 'age': 19},
    1008: {'name': '钟灵', 'sex': False}
}
students.update(others)
print(students)      # {1001: {...}, 1005: {...}, 1010: {...}, 1008: {...}}
```

跟列表一样，从字典中删除元素也可以使用 `del` 关键字，在删除元素的时候如果指定的键索引不到对应的值，一样会引发 `KeyError` 异常，具体的做法如下所示。

```Python
person = {'name': '王大锤', 'age': 25, 'sex': True}
del person['age']
print(person)    # {'name': '王大锤', 'sex': True}
```

## 字典的应用

我们通过几个简单的例子来讲解字典的应用。

**例子 1**：输入一段话，统计每个英文字母出现的次数。

```Python
sentence = input('请输入一段话: ')
counter = {}
for ch in sentence:
    if 'A' <= ch <= 'Z' or 'a' <= ch <= 'z':
        counter[ch] = counter.get(ch, 0) + 1
for key, value in counter.items():
    print(f'字母{key}出现了{value}次.')
```

**例子 2**：在一个字典中保存了股票的代码和价格，找出股价大于 100 元的股票并创建一个新的字典。

> **说明**：可以用字典的生成式语法来创建这个新字典。

```Python
stocks = {
    'AAPL': 191.88,
    'GOOG': 1186.96,
    'IBM': 149.24,
    'ORCL': 48.44,
    'ACN': 166.89,
    'FB': 208.09,
    'SYMC': 21.29
}
stocks2 = {key: value for key, value in stocks.items() if value > 100}
print(stocks2)
```





























