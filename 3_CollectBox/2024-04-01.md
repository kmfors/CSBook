# 错误处理的由来：

比如说：数组越界。我们提供一个接口，需要传参。但是我们不知道使用者在使用的时候会出现什么样的错误，可能使用者一不小心访问数组越界，而遇到这种情况，我们又没有很好的方式去提醒使用者。因为这种未知的
情况是基于什么问题发生的，以至于不知道该如何处理。而且也不能保证每次在检测的时候都能检测出问题。

因此最佳的解决方案是实现者负责检测可能产生的问题，然后通知使用者，之后使用者可以采取适当的应对措施。--异常处理机制

处理异常的程序放入到一个try中。

无论什么时候只要我们试图定义一个函数，就应该考虑它的前置条件是什么，以及检验该条件的过程是否足够简洁。（前置条件没有得到满足，函数将拒绝执行）。

---
# 不变式

什么是不变式？一条假定某事为真的声明称为类的不变式。建立类的不变式是构造函数的任务？成员函数可以依赖于该函数不变式？另一作用是确保当成员函数退出时不变式仍然成立。

比如说，构造函数在执行时，虽然有给数据成员传参，但是却没有校验传的实参是否有效；如果无效，很有可能函数在执行一半时崩掉，从而影响了原有功能的完全执行（因为我们假定构造函数是不可能崩的）。

---
# 静态断言：
大多数系统以及自定义类型接口的主要目的就是能够在编译时发现错误。

把表达某种期望的语句称为断言（assertion），比如说static_assert机制（作用于任何可以表达为常量表达式的东西）

比如：static_assert(A, S)的作用是当A不为true时，把S作为一条编译器错误信息输出。主要用于为泛型编程中作为形参的类型设置断言