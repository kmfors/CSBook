1、为什么不固定整数变量的大小？

简而言之，这要追溯到 C 语言的早期，当时计算机运行速度很慢，性能是最重要的。 C 语言故意不确定整数的大小，这样编译器实现者就可以为 int 选择一个在目标计算机体系结构上性能最佳的大小。

不固定整数变量的大小有点糟糕，按照现代标准，是的。作为程序员，不得不处理范围不确定的类型有点可笑。考虑一下 int 类型。 int 的最小大小是 2 字节，但在现代架构上通常是 4 字节。

如果你假设 int 是 4 字节，因为这是最有可能的，那么在 int 实际上是 2 字节的架构上，你的程序很可能会出现错误（因为你很可能会在 2 字节变量中存储需要 4 字节的值，这将导致溢出或未定义的行为）。

如果假设 int 只有 2 字节，以确保最大兼容性，那么可以安全存储在 int 中的数值范围就会受到很大限制。而在 int 实际为 4 字节的系统中，每个 int 所分配的内存只有一半没有使用。

在大多数情况下，我们每次只实例化少量的 int 变量，而且这些变量通常会在创建它们的函数结束时销毁。在这种情况下，浪费每个变量 2 字节的内存并不是问题（范围有限才是更大的问题）。但是，如果我们的程序分配了数千或数百万个 int 变量，那么每个变量浪费 2 字节内存就会对程序的整体内存使用量产生重大影响。

# 固定宽度整数

为了解决上述问题，C99 定义了一组固定宽度的整数（在 stdint.h 头文件中），这些整数保证在任何体系结构上大小相同。

![[20240805211553.png]]

作为 C++11 的一部分，C++ 正式采用了这些固定宽度的整数。可以通过包含 `<cstdint>` 头文件来访问这些整数，它们被定义在 std 命名空间内。下面是一个例子：

```c++
#include <cstdint> // for fixed-width integers
#include <iostream>

int main()
{
    std::int16_t i{5};
    std::cout << i << '\n';
    return 0;
}
```

固定宽度整数通常有两个缺点。

1、首先，固定宽度整数并不能保证在所有架构上都能定义。它们只存在于基本类型与其宽度相匹配并遵循特定二进制表示法的系统中。在不支持固定宽度整数的体系结构上，你的程序将无法编译。不过，鉴于大多数现代体系结构已将 8/16/32/64 位变量标准化，除非你的程序需要移植到某些特殊的大型机或嵌入式体系结构上，否则这不太可能成为一个问题。

2、其次，如果使用固定宽度的整数，在某些体系结构上可能会比更宽的类型更慢。例如，如果你需要一个保证为 32 位的整数，你可能会决定使用 std::int32_t，但实际上你的 CPU 在处理 64 位整数时可能会更快。不过，CPU 处理给定类型的速度更快，并不意味着程序的整体速度会更快--现代程序通常受内存使用量而非 CPU 的限制，内存占用越大，程序的运行速度就越慢，而 CPU 处理速度越快，程序的运行速度就越快。如果不进行实际测量，很难知道这一点。

为了帮助解决上述弊端，C++ 还定义了两组保证定义的整数。

快速类型（`std::int_fast#_t` 和 `std::uint_fast#_t` ）提供宽度至少为 # 位（其中 # = 8、16、32 或 64）的最快有符号/无符号整数类型。例如，std::int_fast32_t 将提供至少 32 位的最快有符号整数类型。所谓最快，是指 CPU 处理速度最快的整数类型。

最小类型（`std::int_least #_t` 和 `std::uint_least #_t` ）提供宽度至少为 # 位（其中 # = 8、16、32 或 64）的最小有符号/无符号整数类型。例如，std::uint_least32_t 将提供宽度至少为 32 位的最小无符号整数类型。

```c++
#include <cstdint> // for fast and least types
#include <iostream>

int main()
{
    std::cout << "least 8:  " << sizeof(std::int_least8_t) * 8 << " bits\n";
    std::cout << "least 16: " << sizeof(std::int_least16_t) * 8 << " bits\n";
    std::cout << "least 32: " << sizeof(std::int_least32_t) * 8 << " bits\n";
    std::cout << '\n';
    std::cout << "fast 8:  " << sizeof(std::int_fast8_t) * 8 << " bits\n";
    std::cout << "fast 16: " << sizeof(std::int_fast16_t) * 8 << " bits\n";
    std::cout << "fast 32: " << sizeof(std::int_fast32_t) * 8 << " bits\n";

    return 0;
}
```

打印结果如下：

    least 8:  8 bits
    least 16: 16 bits
    least 32: 32 bits
    
    fast 8:  8 bits
    fast 16: 32 bits
    fast 32: 32 bits

你可以看到，std::int_least16_t 是 16 位，而 std::int_fast16_t 实际上是 32 位。这是因为在作者的机器上，32 位整数的处理速度比 16 位整数快。

然而，这些快速、最少的整数也有其自身的缺点： 首先，实际使用它们的程序员并不多，不熟悉它们可能会导致错误。其次，快速类型可能会导致内存浪费，因为它们的实际大小可能比其名称所表示的要大。更严重的是，由于快速/最小整数的大小可能不同，在它们解析为不同大小的架构上，程序可能会表现出不同的行为。例如

```c++
#include <cstdint>
#include <iostream>

int main()
{
    std::uint_fast16_t sometype { 0 };
    sometype = sometype - 1; // intentionally overflow to invoke wraparound behavior

    std::cout << sometype << '\n';

    return 0;
}
```

根据 std::uint_fast16_t 是 16 位、32 位还是 64 位，这段代码会产生不同的结果。在对程序进行严格测试之前，很难知道程序在哪些地方可能无法按照预期运行。

鉴于基本整型、固定宽度整型、快速/最小整型以及带符号/不带符号挑战的各种优缺点，关于整型的最佳实践几乎没有达成共识。

我们的立场是，正确比快速好，编译时失败比运行时失败好。因此，如果需要固定大小的整型，我们建议避免使用快速/最小类型，而使用固定宽度类型。如果后来发现需要支持的平台无法编译特定的定宽类型，这时可以决定如何迁移程序（并彻底重新测试）。



> [!TIP]
>
> - 当整数的大小不重要时（例如，数字总是在 2 字节带符号整数的范围内），并且变量的寿命很短（例如，在函数结束时销毁），首选 int。 
> - 在存储需要保证范围的数量时，优先使用 `std::int#_t`。
> - 在进行位操作或需要定义明确的环绕行为时，首选 `std::uint#_t` 。


std::size_t 是实现定义的无符号整型的别名。它在标准库中用于表示对象的字节大小或长度。

std::size_t 定义在许多不同的头文件中。如果需要使用 std::size_t，`<cstddef>` 是最好的头文件，因为它包含的其他定义标识符最少。

 也就是说，对于 32 位应用程序，std::size_t 通常是 32 位无符号整数，而对于 64 位应用程序，std::size_t 通常是 64 位无符号整数。

std::size_t 对在系统中创建的对象的大小设置了上限。

```c++
#include <cstddef> // for std::size_t
#include <iostream>

int main()
{
    std::cout << sizeof(std::size_t) << '\n';

    return 0;
}
```

sizeof 必须能够以 std::size_t 类型的值返回对象的字节大小.因此，如果任何对象的大小（以字节为单位）大于 std::size_t 类型对象所能容纳的最大值，就会被认为是格式错误（并会导致编译错误）。

例如，假设系统中的 std::size_t 大小为 4 字节。无符号 4 字节整型范围是 0 至 4,294,967,295。因此，一个 4 字节的 std::size_t 对象可以保存 0 至 4,294,967,295 之间的任何值。任何字节大小在 0 到 4,294,967,295 之间的对象都可以用 std::size_t 类型的值来返回其大小，因此这没有问题。但是，如果一个对象的字节大小大于 4,294,967,295 字节，那么 sizeof 将无法准确返回该对象的大小，因为该值将超出 std::size_t 的范围。因此，在本系统中无法创建大于 4,294,967,295 字节的对象。

std::size_t 的大小为对象的大小规定了严格的数学上限。实际上，最大的可创建对象可能比这个值还要小（可能小得多）。


