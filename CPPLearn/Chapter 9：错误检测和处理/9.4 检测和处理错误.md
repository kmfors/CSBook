在第 9.3 课 -- C++ 中的常见语义错误中，我们介绍了新手程序员在使用 C++ 语言时会遇到的多种常见 C++ 语义错误。如果错误是由误用的语言特性或逻辑错误造成的，则可以简单地进行纠正。

但是，程序中的大多数错误并不是由于无意中误用了语言特性而造成的，相反，大多数错误都是由于程序员的错误假设或缺乏正确的错误检测处理而造成的。

在本课中，我们将讨论函数内部的错误处理策略（出错时该怎么办）。在随后的课程中，我们将讨论验证用户输入，然后介绍一个有用的工具来帮助记录和验证假设。

# 1. 处理函数中的错误

函数失效的原因有多种--调用者可能传入了一个值无效的参数，或者函数体内部出现故障。例如，打开文件进行读取的函数可能会在找不到文件的情况下失败。出现这种情况时，您有很多选择。处理错误没有最好的方法，这取决于问题的性质以及是否可以修复。

有 4 种一般策略可供选择： 

- 在函数内部处理错误
- 将错误反馈给调用者处理
- 停止程序
- 抛出异常

# 2. 在函数内部处理错误

如果可能，最好的策略是在发生错误的同一函数中恢复错误，这样就可以在不影响函数外任何代码的情况下控制和纠正错误。这里有两种选择：重试直到成功，或者取消正在执行的操作。

如果错误发生的原因超出了程序的控制范围，程序可以重试，直到成功为止。例如，如果程序需要互联网连接，而用户失去了连接，程序可能会显示警告，然后使用循环周期性地重新检查互联网连接。或者，如果用户输入了无效输入，程序可以要求用户再试一次，并循环运行，直到用户成功输入有效输入为止。我们将在下一课展示处理无效输入和使用循环重试的示例：

另一种策略是忽略错误和/或取消操作。例如：

```c++
// Silent failure if y=0
void printIntDivision(int x, int y)
{
    if (y != 0)
        std::cout << x / y;
}
```

在上例中，如果用户**输入的 y 值无效，我们将忽略打印除法运算结果的请求**。这样做的主要挑战在于，调用者或用户无法确定是否出错。在这种情况下，打印错误信息可能会有所帮助：

```c++
void printIntDivision(int x, int y)
{
    if (y != 0)
        std::cout << x / y;
    else
        std::cout << "Error: Could not divide by zero\n";
}
```

但是，如果调用函数希望被调用函数产生返回值或一些有用的副作用，那么忽略错误可能就不是一种选择。函数内部的错误忽略在通常没有错误信息的打印的情况下，对调用者来说不够友好。因为我们无法预测用户的使用场景，如果引发问题，那问题对于双方讲都是需要排查的辛苦过程。

# 3. 将错误反馈给调用者

在许多情况下，检测错误的函数无法合理地处理错误。例如，请看下面的函数：

```c++
int doIntDivision(int x, int y)
{
    return x / y;
}
```

如果 y 为 0，我们该怎么办？ 我们不能直接跳过程序逻辑，因为函数需要返回一些值。我们不应该要求用户为 y 输入一个新值，因为这是一个计算函数，在其中引入输入例程可能对调用该函数的程序合适，也可能不合适。

在这种情况下，**最好的办法是把错误传回给调用者，希望调用者能够处理这个错误**。

如果函数的返回类型是 void，那么可以将其改为返回表示成功或失败的 bool 类型。例如将 printIntDivision 函数替换为：

```c++
bool printIntDivision(int x, int y)
{
    if (y == 0) {
        std::cout << "Error: could not divide by zero\n";
        return false;
    }
    std::cout << x / y;

    return true;
}
```

这样，调用者就可以检查返回值，查看函数是否因某种原因而失败。

如果函数返回的是正常值，情况就会复杂一些。在某些情况下，并不会使用全部的返回值。在这种情况下，我们可以使用正常情况下不可能出现的返回值来表示错误。例如，请看下面的函数：

```c++
// The reciprocal of x is 1/x
double reciprocal(double x) {
    return 1.0 / x;
}
```

某个数 x 的倒数定义为 1/x，一个数乘以它的倒数等于 1。但是，如果用户以 `reciprocal(0.0)` 的形式调用这个函数，会发生什么情况呢？ 我们会出现除以零的错误并导致程序崩溃，因此我们显然应该防止这种情况的发生。但是这个函数必须返回一个 double 值，那么我们应该返回什么值呢？ 事实证明，这个函数永远不会产生 0.0 的合法结果，所以我们可以返回 0.0 来表示出错。

```c++
// The reciprocal of x is 1/x, returns 0.0 if x=0
double reciprocal(double x) {
    if (x == 0.0)
       return 0.0;
    return 1.0 / x;
}
```

哨兵值（ sentinel value）是在函数或算法中具有特殊意义的值。在上述的 `reciprocal()` 函数中，0.0 是表示函数失败的哨兵值。调用者可以测试返回值是否与哨兵值相匹配--如果相匹配，那么调用者就知道函数失败了。但是，如果函数可以产生全部返回值，那么使用哨兵值来表示错误就有问题了（因为调用者无法判断返回值是有效值还是错误值）。

提醒：在这种情况下，返回一个 std::optional 将是一个不错的选择。在 12.15 课程中

# 4. 致命错误

如果错误严重到程序无法继续正常运行，则称为不可恢复错误（也称为致命错误）。在这种情况下，最好的办法就是终止程序。如果代码位于 `main()` 或直接从 `main()` 调用的函数中，最好的办法就是让 `main()` 返回一个非零状态代码。但是，如果你的代码位于嵌套子函数的深处，则可能不方便或不可能将错误一直传递回 `main()`。在这种情况下，可以使用停止语句，如 `std::exit()`。

```c++
double doIntDivision(int x, int y) {
    if (y == 0) {
        std::cout << "Error: Could not divide by zero\n";
        std::exit(1);
    }
    return x / y;
}
```

# 5. 异常

由于将错误从函数返回给调用者是一件复杂的事情（而且有许多不同的方法会导致不一致，而不一致又会导致错误），C++ 提供了一种完全独立的方法来将错误传回给调用者：`exceptions`。

其基本思想是，当发生错误时，就会抛出一个异常。如果当前函数没有捕获该错误，函数的调用者就有机会捕获该错误。如果调用者没有捕捉到错误，则调用者的调用者有机会捕捉到错误。错误会在调用堆栈中逐步上移，直到被捕获并处理（此时执行继续正常进行），或直到 `main()` 无法处理该错误（此时程序以异常错误结束）。

我们将在本教程系列的第 27 章介绍异常处理。

# 6. 何时使用 `std::cout` vs `std::cerr` vs `logging`

您可能想知道何时应该使用 std::cerr vs std::cout vs 记录到文本文件。

默认情况下，std::cout 和 std::cerr 都会将文本打印到控制台。不过，现代操作系统提供了将输出流重定向到文件的方法，这样就可以捕获输出，以便日后查看或自动处理。

在讨论中，有必要区分两类应用：

- Interactive applications（交互式应用程序），其运行后用户会与之交互的程序。大多数独立应用程序，如游戏和音乐应用程序，都属于这一类。
- Non-interactive applications（非交互式应用程序），不需要用户进行交互操作的应用程序。这些程序的输出可用作另一个应用程序的输入。

在非交互式应用程序中，有两种类型：

- Tools（工具）是一种非交互式应用程序，启动后通常会立即产生某种结果，并在产生这种结果后终止。 Unix 的 grep 命令就是一个例子，它是一种搜索文本中符合某种模式的行的工具。
- Services（服务）是一种非交互式应用程序，通常在后台静默运行，以执行某些正在进行的功能。病毒扫描程序就是一个例子。

这里有一些经验法则：

- 所有面向用户的常规文本均使用 `std::cout`。
- 对于交互式程序，使用 `std::cout` 来显示面向用户的正常错误信息（例如 "您的输入无效"）。使用 `std::cerr` 或日志文件获取状态和诊断信息，这些信息可能有助于诊断问题，但对普通用户来说可能并不有趣。这可能包括技术警告和错误（例如，函数 x 输入错误）、状态更新（例如，成功打开文件 x，连接互联网服务 x 失败）、长期任务的完成百分比（例如，编码完成 50%）等......
- 对于非交互式程序（工具或服务），使用 `std::cerr` 仅用于错误输出（如无法打开文件 x）。这样可以将错误与正常输出分开显示或解析。
- 对于任何事务性应用程序类型（如处理特定事件的应用程序，如交互式网络浏览器或非交互式网络服务器），可使用**日志文件**生成事务性事件日志，以便日后查看。这可以包括向日志文件输出正在处理的文件、完成百分比的更新、开始某些计算阶段的时间戳、警告和错误信息等。