# 所有权与借用

## 所有权

所有的程序都必须和计算机内存打交道，如何从内存中申请空间来存放程序的运行内容，如何在不需要的时候释放这些空间，成了重中之重，也是所有编程语言设计的难点之一。在计算机语言不断演变过程中，出现了三种流派：

- 垃圾回收机制(GC)，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
- 手动管理内存的分配和释放, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
- 通过所有权来管理内存，编译器在编译时会根据一系列规则进行检查

其中 Rust 选择了第三种，最妙的是，这种检查只发生在编译期，因此对于程序运行期，不会有任何性能上的损失。



### 栈与堆

在此之前先了解一下，栈与堆的概念。

#### 性能区别

在栈上分配内存比在堆上分配内存要快，因为入栈时操作系统无需进行函数调用（或更慢的系统调用）来分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备，如果当前进程分配的内存页不足时，还需要进行系统调用来申请更多内存。 因此，处理器在栈上分配数据会比在堆上分配数据更加高效。

#### 所有权与堆栈

当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。

因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 Rust 所有权系统为我们提供的强大保障。

对于其他很多编程语言，你确实无需理解堆栈的原理，但是 **在 Rust 中，明白堆栈的原理，对于我们理解所有权的工作原理会有很大的帮助**。



### 所有权原则

理解了堆栈，接下来看一下 *关于所有权的规则*，首先请谨记以下规则：

> [!IMPORTANT]
>
> 1. Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
> 2. 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
> 3. 当所有者（变量）离开作用域范围时，这个值将被丢弃(drop)



#### 变量作用域

作用域是一个变量在程序中有效的范围，假如有这样一个变量：

```rust
// 变量 s 绑定一个字符串字面值
let s = "hello"; // 字符串字面值被硬编码到程序代码中
```

`s` 变量从声明的点开始到当前作用域的结束是有效的（以大括号为域界），脱离作用域便会回收失效。



### 变量绑定背后的数据交互

#### 转移所有权

先看一段代码：

```rust
let x = 5;
let y = x;
```

这段代码并 **没有发生所有权的转移**，原因很简单：代码首先将 `5` 绑定到变量 `x`，接着 **拷贝** `x` 的值赋给 `y`，最终 `x` 和 `y` 都等于 `5`。

因为整数是 Rust 基本数据类型，是固定大小的简单值，因此这两个值都是通过 **自动拷贝** 的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。整个过程中的赋值都是通过 **值拷贝** 的方式完成（发生在栈中），因此并 **不需要所有权转移**。

> [!NOTE]
>
> 疑问：这种拷贝不消耗性能吗？实际上，这种栈上的数据足够简单，而且拷贝非常非常快，只需要复制一个整数大小（`i32`，4 个字节）的内存即可，因此在这种情况下，拷贝的速度远比在堆上创建内存来得快的多。并且实际上，Rust 基本类型都是通过自动拷贝的方式来赋值的，就像上面代码一样。

再来看一段代码：

```rust
let s1 = String::from("hello");
let s2 = s1;
```

注意：`String` 不是基本类型，而是存储在堆上的，因此不能自动拷贝。实际上，String 类型是一个复杂类型，由存储在堆中的堆指针、字符串长度、字符串容量共同组成的。下面对上面的第二行代码分成两种情况讨论：

1. 拷贝 String 和存储在堆上的字节数组，如果该语句是深拷贝，那无论是 String 本身还是底层上的堆数据，都是会被全部拷贝，否则对会对性能造成巨大影响。
2. 只拷贝 String 本身，这样的拷贝非常快；但所有权规则中规定：一个值只允许有一个所有者。而真实的字符串数据却有两个所有者：`s1` 与 `s2`，当它们离开作用域时，都会尝试释放相同的内存，可能会引发 double free 的内存 BUG 漏洞。

因此，Rust 这样解决问题：

1. String 申请的内存的所有权赋予给了 s1
2. s1 将所拥有内存的所有权转移至 s2，即失效
3. s1 在完成所有权的转移后遂失效，脱离作用域后无需释放任何数据

再来看看，在所有权转移后再来使用旧的所有者（反例），会发生什么：

```rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1); // 禁止你使用无效的引用
```


再来看一段代码：

```c++
fn main() {
    // &str 是字面量字符串类型
    let x: &str = "hello, world";
    let y = x;
    println!("{},{}",x,y);
}
```

这段代码和之前的 String 有一个本质上的区别：在 String 的例子中 s1 持有了通过 `String::from("hello")` 创建的值的内存所有权，而这个例子中，x 只是引用了存储在二进制可执行文件（binary）中的字符串 `"hello, world"`，并没有持有所有权。

因此 `let y = x` 中，仅仅是对该引用进行了拷贝，此时 y 和 x 都引用了同一个字符串。如果还不理解也没关系，当学习了下一章节 "引用与借用" 后，大家自然而言就会理解。

#### 克隆（深拷贝）

首先，**Rust 永远也不会自动创建数据的 “深拷贝”**。因此，任何 **自动** 的复制都不是深拷贝，可以被认为对运行时性能影响较小。

如果我们 **确实** 需要深度复制 `String` 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 `clone` 的方法。

```rust
let s1 = String::from("hello");
let s2 = s1.clone();

println!("s1 = {}, s2 = {}", s1, s2);
```

这段代码能够正常运行，说明 `s2` 确实完整的复制了 `s1` 的数据。

如果代码性能无关紧要，例如初始化程序时或者在某段时间只会执行寥寥数次时，你可以使用 `clone` 来简化编程。但是对于执行较为频繁的代码（热点路径），使用 `clone` 会极大的降低程序性能，需要小心使用！

#### 拷贝（浅拷贝）

浅拷贝只发生在栈上，因此性能很高，在日常编程中，浅拷贝无处不在。再看之前的例子：

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

原因是像整型这样的基本类型在编译时是已知大小的，会被存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 `y` 后使 `x` 无效（`x`、`y` 都仍然有效）。换句话说，这里没有深浅拷贝的区别，因此这里调用 `clone` 并不会与通常的浅拷贝有什么不同，我们可以不用管它（可以理解成在栈上做了深拷贝）。

Rust 有一个叫做 `Copy` 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 `Copy` 特征，一个旧的变量在被赋值给其他变量后仍然可用，也就是赋值的过程即是拷贝的过程。

那么什么类型是可 `Copy` 的呢？可以查看给定类型的文档来确认，这里可以给出一个通用的规则： **任何基本类型的组合可以 `Copy` ，不需要分配内存或某种形式资源的类型是可以 `Copy` 的**。如下是一些 `Copy` 的类型：

- 所有整数类型，比如 `u32`
- 布尔类型，`bool`，它的值是 `true` 和 `false`
- 所有浮点数类型，比如 `f64`
- 字符类型，`char`
- 元组，当且仅当其包含的类型也都是 `Copy` 的时候。比如，`(i32, i32)` 是 `Copy` 的，但 `(i32, String)` 就不是
- 不可变引用 `&T` ，例如 [转移所有权](https://course.rs/basic/ownership/ownership.html#转移所有权) 中的最后一个例子，**但是注意：可变引用 `&mut T` 是不可以 Copy 的**



### 函数的值传参与返回

#### 值传参

与 let 语句一样，将参数值传递给函数，一样会发生移动（非 Copy 类型）或拷贝，下面的代码体现了所有权、作用域的规则：

```rust
fn main() {
    let s = String::from("hello");  // 分配内存，绑定 s
    takes_ownership(s);             // 内存所有权发生转移
    // ... s 失效，值已被移走
    let x = 5;                      // 分配内存，绑定 x
    makes_copy(x);                  // 发生内存拷贝给函数内的形参
    // 但 i32 是 Copy 的，所以在后面可继续使用 x
} // s 的值已被移走

fn takes_ownership(some_string: String) { // 内存所有权移动至形参 some_string
    println!("{}", some_string);
} // 形参脱离作用域，占有的内存被释放

fn makes_copy(some_integer: i32) { // 发生内存拷贝，绑定形参 some_integer
    println!("{}", some_integer);
} // 形参脱离作用域，占有的内存被释放这里
```

#### 函数返回

同样的，函数返回值也有所有权，例如:

```rust
fn main() {
    let s1 = gives_ownership(); // 转移至 s1
    let s2 = String::from("hello"); 

    // 内存所有权由 s2 转移至 s3
    let s3 = takes_and_gives_back(s2);                                   
} // s3 脱离作用域并被丢弃; s2 脱离作用域，但已被移走; s1 移出作用域并被丢弃

// 将返回值移动给调用它的函数
fn gives_ownership() -> String {             
    // some_string 绑定分配的内存
    let some_string = String::from("hello");
    some_string   // 通过返回转移内存
}

// 将传入字符串并返回该值
fn takes_and_gives_back(a_string: String) -> String {
    a_string  // 通过返回转移形参内存
}
```

所有权很强大，避免了内存的不安全性，但是也带来了一个新麻烦： **总是把一个值传来传去来使用它**。 传入一个函数，很可能还要从该函数传出去，结果就是语言表达变得非常啰嗦，幸运的是，Rust 提供了新功能解决这个问题。



## 引用与借用

上节中提到，如果仅仅支持通过转移所有权的方式获取一个值，那会让程序变得复杂。 Rust 能否像其它编程语言一样，使用某个变量的指针或者引用呢？答案是可以。

Rust 通过 `借用(Borrowing)` 这个概念来达成上述的目的，**获取变量的引用，称之为借用(borrowing)，并最终是要物归原主的**

### 引用与解引用

常规引用是一个指针类型，指向了对象存储的内存地址：

```rust
fn main() {
    let x = 5;
    let y = &x; // & 符获取 x 的地址，自动推导 y 为引用类型

    assert_eq!(5, x);
    assert_eq!(5, *y); // * 符解引用，获取 x 值
}
```

### 不可变引用

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

能注意到两点：

1. 无需像上章一样：先通过函数参数传入所有权，然后再通过函数返回来传出所有权，代码更加简洁
2. `calculate_length` 的参数 `s` 类型从 `String` 变为 `&String`

这里，`&` 符号即是引用，它们允许你使用值，但是不获取所有权，如图所示：

<img src="../../../1_store/1_asset/image-20241031212347068.png" alt="image-20241031212347068" style="zoom:60%;" />

如果尝试修改借用的变量，会引发报错

```rust
fn main() {
    let s = String::from("hello");
    change(&s);
}

fn change(some_string: &String) {
    // some_string只具有读取权，不具有写入权
    some_string.push_str(", world");
}
```

正如变量默认不可变一样，引用指向的值默认也是不可变的，没事，来一起看看如何解决这个问题。

### 可变引用

只需要一个小调整，即可修复上面代码的错误：

```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

首先，声明 `s` 是可变类型，其次创建一个可变的引用 `&mut s` 和接受可变引用参数 `some_string: &mut String` 的函数。可变引用的传递必须从头到尾都是可变类型的。

#### Only One 1

不过可变引用并不是随心所欲、想用就用的，它有一个很大的限制： **同一作用域，特定的数据只能有一个可变引用**：

```rust
fn main() {
    let mut s = String::from("hello");

    let r1 = &mut s;
    let r2 = &mut s; // error,second mutable borrow occurs here

    println!("{}, {}", r1, r2);
}
```

这段代码出错的原因在于，第一个可变借用 `r1` 必须要持续到最后一次使用的位置 `println!`，在 `r1` 创建和最后一次使用之间，我们又尝试创建第二个可变借用 `r2`，从而导致编译时报错。这是编译器 `borrow checker` 特性之一，这种限制的好处就是使 Rust 在编译期就避免数据竞争，数据竞争可由以下行为造成：

- 两个或更多的指针同时访问同一数据
- 至少有一个指针被用来写入数据
- 没有同步数据访问的机制

数据竞争会导致未定义行为，这种行为很可能超出我们的预期，难以在运行时追踪，并且难以诊断和修复。而 Rust 避免了这种情况的发生，因为它甚至不会编译存在数据竞争的代码！

很多时候，大括号可以帮我们解决一些编译不通过的问题，通过手动限制变量的作用域：

```rust
fn main() {
    let mut s = String::from("hello");
    {
        let r1 = &mut s;
    } // r1 脱离作用域，释放自身对可变引用的绑定

    let r2 = &mut s;
}
```

#### Only One 2

下面的代码会导致一个错误：

```rust
let mut s = String::from("hello");

let r1 = &s; // 没问题
let r2 = &s; // 没问题
let r3 = &mut s; // 大问题

println!("{}, {}, and {}", r1, r2, r3);
```

可以创建多个不可变引用的变量（读权限），但创建它们的同时，不能创建可变引用的变量（写权限）。在同一作用域下，不可变引用与可变引用不能同时存在。

> [!NOTE]
>
> 注意，引用的作用域 `s` 从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号 `}`



### 悬垂引用

悬垂引用也叫做悬垂指针，意思为指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。在 Rust 中编译器可以确保引用永远也不会变成悬垂状态：当你获取数据的引用后，编译器可以确保数据不会在引用结束前被释放，要想释放数据，必须先停止其引用的使用。

让我们尝试创建一个悬垂引用，Rust 会抛出一个编译时错误：

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");
    &s
}
```

错误信息引用了一个我们还未介绍的功能：生命周期(lifetimes)。

因为 `s` 是在 `dangle` 函数内创建的，当 `dangle` 的代码执行完毕后，`s` 将被释放，但是此时我们又尝试去返回它的引用。这意味着这个引用会指向一个无效的 `String`，这可不对！

其中一个很好的解决方法是直接返回 `String`：

```rust
fn no_dangle() -> String {
    let s = String::from("hello");
    s // 内存所有权发生转移
}
```

### 借用规则总结

总的来说，借用规则如下：

- 同一时刻，你只能拥有要么一个可变引用，要么任意多个不可变引用
- 引用的原始内存所有者的对象必须总是有效的
