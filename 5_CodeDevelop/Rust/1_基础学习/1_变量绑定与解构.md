# Rust 基本概念

开始之前先通过一段代码来简单浏览下 Rust 的语法：

```rust

// main 是 Rust 程序的入口函数，该函数目前无返回值。
fn main() {
    // 使用let来声明变量，进行绑定，a是不可变的
    // 此处没有指定a的类型，编译器会默认根据a的值为a推断类型：i32，有符号32位整数
    let a = 10; // 语句末尾以分号结尾
    let b: i32 = 20; // 主动指定b的类型为i32
    
    // 这里有两点值得注意：
    // 1. 可以在数值中带上类型:30i32，表示数值是30，类型是i32
    // 2. c是可变的，mut是mutable的缩写
    let mut c = 30i32; 
    
    // 在数值和类型中间可以添加下划线，让可读性更好
    let d = 30_i32;
    
    // 跟其它语言一样，可以使用一个函数的返回值来作为另一个函数的参数
    let e = add(add(a, b), add(c, d));

    // println!是宏调用，{}是占位符
    println!("( a + b ) + ( c + d ) = {}", e);
}

// 定义一个函数，输入两个i32类型的32位有符号整数，返回它们的和
fn add(i: i32, j: i32) -> i32 {
    // 返回相加值，这里可以省略return
    i + j
}
```

手动敲一遍才是最好的练习。

内容需要不断的更新，语法不重要，思想最重要。

## 变量特性

变量的可变性是需要我们手动设置的。

### 变量命名

通常，对于 **type-level** 的构造 Rust 倾向于使用 **驼峰命名法**，而对于 **value-level** 的构造使用 **蛇形命名法**。

- 对于 **驼峰命名法**，复合词的缩略形式我们认为是一个单独的词语，所以 **只对首字母进行大写**：
  - 使用 `Uuid` 而不是 ~~`UUID`~~
  - 使用 `Usize` 而不是 ~~`USize`~~
  - 使用 `Stdin` 而不是 ~~`StdIn`~~。
- 对于 **蛇形命名法**，缩略词用全小写：`is_xid_start`。
- 对于 **蛇形命名法**（包括全大写的 `SCREAMING_SNAKE_CASE`），除了最后一部分，其它部分的词语都不能由单个字母组成： `btree_map` 而不是 ~~`b_tree_map`~~，`PI_2` 而不是 ~~`PI2`~~.

### 变量绑定

rust 的核心原则：任何的内存对象都具有其归属性，即所有权。所谓的变量绑定就是将内存对象绑定给一个变量，让这个变量成为该对象的所有者，而该对象之前的所有者则失去其所有权。

### 变量可变性

定义的变量在默认情况下是不可变的（rust 语言特性之一），但可通过 `mut` 关键字使变量具备可变性，满足代码编写的灵活性与安全性。示例代码如下：

```rust
fn main() {
    let x = 5; // x 为不可变变量
    let mut x = 5; // x 为不可变变量
    println!("The value of x is: {}", x);
    
    x = 6; // compile error，由于 x 是不可变变量 
    println!("The value of x is: {}", x);
}
```

### 未使用变量

如果创建了一个变量却不在任何地方使用它，Rust 通常会给出一个警告，因为这可能会是个 BUG。但是有时创建一个不会被使用的变量是有用的，因此可以用下划线作为变量名的开头，从而告诉 Rust 忽略未使用的变量，不再警告。

```rust
fn main() {
    let _x = 5; // 忽略未使用的警告
    let y = 10;
}
```

## 变量解构

`let` 表达式不仅仅用于变量的绑定，还能进行复杂变量的解构：从一个相对复杂的变量中，匹配出该变量的一部分内容：

```rust
fn main() {
    let (a, mut b): (bool,bool) = (true, false);
    
    // a 为 true，不可变; b 为 false，可变
    println!("a = {:?}, b = {:?}", a, b);

    b = true;
    assert_eq!(a, b);
}
```

解构式赋值：可以在赋值语句的左式中使用元组、切片和结构体模式。

## 变量与常量

与不可变变量一样，常量也是绑定到一个常量名且不允许更改的值，但是常量和变量之间存在一些差异：

- 常量不允许使用 `mut`。**常量不仅仅默认不可变，而且自始至终不可变**，因为常量在编译完成后，已经确定它的值。
- 常量使用 `const` 关键字而不是 `let` 关键字来声明，并且值的类型**必须**标注。

```rust
const MAX_POINTS: u32 = 100_000;
```

Rust 常量的命名约定是全部字母都使用大写，并使用下划线分隔单词，另外对数字字面量可插入下划线以提高可读性。常量可以在任意作用域内声明，包括全局作用域，在声明的作用域内，常量在程序运行的整个过程中都有效。对于需要在多处代码共享一个不可变的值时非常有用。

> [!NOTE]
>
> 在实际使用中，最好将程序中用到的硬编码值都声明为常量，对于代码后续的维护有莫大的帮助。如果将来需要更改硬编码的值，你也只需要在代码中更改一处即可。



## 变量遮蔽

Rust 允许声明相同的变量名，在后面声明的变量会遮蔽掉前面声明的，如下所示：

```rust
fn main() {
    let x = 5;

    let x = x + 1; // 在所在作用域下对前面的 x 进行遮蔽
    {
        // 在当前的花括号作用域内，对之前的 x 进行遮蔽
        let x = x * 2;
        println!("The value of x in the inner scope is: {}", x);
    }
    println!("The value of x is: {}", x);
}
```

变量遮蔽的用处在于，如果你在某个作用域内无需再使用之前的变量（在被遮蔽后，无法再访问到之前的同名变量），就可以重复的使用变量名字，而不用绞尽脑汁去想更多的名字。但 Rust 对类型的要求很严格，是不允许将整数类型 `usize` 赋值给字符串类型。

```rust
let mut spaces = "   ";
spaces = spaces.len(); // compile error!
```