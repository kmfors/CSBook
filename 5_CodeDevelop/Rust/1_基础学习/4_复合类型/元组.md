## 元组定义

元组，可以这样记忆，用圆括号包裹的数据结构称为元组。

```rust
fn main() {

    // 声明格式 (类型, ...) = (数据, ...)
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

元组内部可以将多个类型数据组合在一起。



## 模式匹配解构元组

```rust
fn main() {

    let tup = (500, 6.4, 1);
	// 模式匹配元组的每个数据项
    let (x, y, z) = tup;

    println!("The value of y is {}", y);
    
}
```

模式匹配，可以想象一个标准表达式，该表达式的每个子项都需要匹配跟自身一模一样的对比物，这个过程叫模式匹配。解构元组好理解，就是将元组内部解构为多个数据项。因此模式匹配结构元素，就是需要一个表达式将自己的子项去匹配元组里的对应的数据项成员，并进行绑定。

## 访问元组

模式匹配可以让我们一次性把元组中的值全部或者部分获取出来；如果只想要访问某个特定元素，则模式匹配略显繁琐，需要使用访问运算符 `.` 进行元组访问：

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0; // 类似下标 x[0]

    let six_point_four = x.1; // 类似下标 x[1]

    let one = x.2; // 类似下标 x[2]
}
```

## 元组示例

常用场景：函数返回可以使用元组返回多个值，代码如下：

```rust
fn main() {
    let s1 = String::from("hello");

    let (s2, len) = calculate_length(s1);

    println!("The length of '{}' is {}.", s2, len);
}

fn calculate_length(s: String) -> (String, usize) {
    let length = s.len();

    (s, length)
}
```

## 问题

问题 1：为什么 12 个元素可以打印，13 个元素就不能打印？

```rust
fn main() {
    // 编译报错
    let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    
    // 编译正常
    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
    println!("too long tuple: {:?}", too_long_tuple);
}
```

注意：变量可以先声明，再绑定值，但不能不绑定值。



打印元组目前是通过宏实现的，但最多只能打印 12 个元素。 有人对这些功能的实现表示担忧（例如，你希望能获取一个元组的头部和尾部，但实际上并不能保证一个元组会按照你指定的顺序存储，因为编译器可以对空间进行优化，这意味着获取尾部并不是一个微不足道的操作）。 至于为什么需要特别的支持，请考虑下面的元组：

```rust
let mixed = (42, true, 3.14, "foo");
```

如果元组中的所有元素都有不同的类型，你将如何遍历这个元组？ 这不能简单地使用普通迭代器和 for 循环来完成。 你需要一些新的类型级语法，而 Rust 目前还缺乏这种语法。