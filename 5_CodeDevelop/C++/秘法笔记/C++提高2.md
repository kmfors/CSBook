# 面向对象的设计

## 三个概念的关系

面向对象的四大基本特征是：抽象、封装、继承、多态。四大基本特征是我们在进行面向对象编程的准则，但是我们在进行面向对象编程之前还需要进行面向对象分析（Object-Oriented Analysis），通过分析业务，确定需求，找出对象，知道我们要干什么，然后就是进行面向对象的设计（ObjectOriented Design），知道我们如何干，最后才是面向对象的编程（Object-Oriented Program），具体的代码实现阶段。



## 面向对象设计（OOD）

不论是面向过程的思维方式，还是面向对象的思维方式，最终都是为了能更好的进行软件开发，而软件开发的唯一真理是“**软件一定会变化**”，而一个好的设计是应该能够轻松的应对变化，能被扩展，并且能够被复用。应该最好是**能以最小的代价满足变化，不用改变现有代码架构来满足扩展**，这样的设计才是一个优秀的设计，所以我们需要进行面向对象的设计。



## UML语言

为了能够更好的进行面向对象的设计，所以需要引用专门的设计语言，也就是我们的UML语言，Unifed Modeling Language， 又称统一建模语言或标准建模语言，是始于1997年一个OMG(ObjectManagement Group)标准，它是一个模型化和软件系统开发的图形化语言。UML为软件开发提供了一些标准的图例(10种)，统一开发思想，从而**促进团队协作**。这10中图例如下：

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052136054.png" alt="image-20230517110924412" style="zoom: 50%;" />



# 类与类的关系

类与类之间的五种关系，继承（泛化）、关联、聚合、组合、依赖。

## 继承（泛化）

继承关系，或者泛化关系，描述的是两个类之间一种很强的关系，基类部分会成为派生类的一部分，在语义上是一个A is B的特点。例如经理是个员工、软件开发工程师是个员工、销售也是一个员工，所以可以设计下面的图例：

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052136206.png" alt="image-20230517111721776" style="zoom: 50%;" />

**继承与泛化的区别**：继承是先有基类，然后从基类产生新的类，也就是派生类；而**泛化是先有派生类，然后多个派生类抽出基类，也就是先有派生类，然后才有基类**。二者考虑的方向不一样，其实泛化更符合面向对象的思想。



## 关联

关联关系，是两个类之间最简单，最单纯的关系，表明两个类之间是有关系的，试想，如果两个类之间没有关系，那就不能满足面向对象的特点，对象与对象之间进行交互，使得彼此之间的状态发生变化的特点。

而关联关系包括两种：双向的关联关系与单向的关联关系。但是不论哪种关联关系，两个类之间彼此并不负责对方的生命周期。注意在语义上是A has B的关系，一种固定的关系。在代码上的表现形式是：使用引用或者指针。

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052136019.png" alt="image-20230517111914951" style="zoom: 50%;" />

单向的关联关系，条件变量与互斥锁（Condition知道MutexLock的存在，但是MutexLock不知道Condition的存在，使用实线箭头从Condition指向MutexLock）

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052136162.png" alt="image-20230517111946618" style="zoom: 50%;" />

## 聚合

是一种比较强的关联关系。对象之间的关系表现为整体和局部，整体部分并不负责局部对象的销毁。语义上表现为A has B。代码上表现为：数据成员以指针或者引用形式存在。使用 **空心菱形箭头表示，部分指向整体**。

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052136918.png" alt="image-20230517112036938" style="zoom:50%;" />

## 组合

更强的一种关联关系。对象之间的关系表现为整体和局部，整体部分负责局部对象的销毁。语义上表现为A has B。代码上表现为，数据成员以子对象成员形式存在。使用 **实心菱形箭头表示，部分指向整体**。

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052136819.png" alt="image-20230517112332929" style="zoom:50%;" />



## 依赖

是两个类之间的一种不确定的关系，语义上是一种A use B的关系，这种关系是偶然的，临时的，并非固定的。在代码上表现为：B作为A的成员**函数参数**；B作为A的成员函数的**局部变量**（B作为A的成员函数的返回值）；A的成员函数调用B的**静态方法**。使用**虚线的箭头，从A指向B**。

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052136048.png" alt="image-20230517112442916" style="zoom: 33%;" />

## 五种关系的总结

1、继承（泛化）表示的是垂直的（纵向）的关系；其他四种表示的是横向的关系。

2、耦合强度：依赖 < 关联 < 聚合 <  组合  <  继承（泛化）

3、语义层面 ：继承（is）、依赖（use）、关联、聚合、组合（has）

4、组合+依赖（基于对象） vs  继承 + 虚函数（面向对象）



# 面对对象的设计原则

在进行面向对象设计的时候，需要考虑类与类之间的关系，这样可以让类之间的关系更加明确。但是，除此之外，在进行面向对象设计的时候，还需要注意满足一定的设计要求，也就是面向对象的设计原则，只有遵循一定的原则，才能更好的满足软件的设计需求，更好的满足变化。而一个优良的系统设计，强调要保持**低耦合、高内聚**的要求，为了满足这个要求，面向对象的设计原则设计了七种， 包括：

单一职责原则 (Single Responsibility Principle)、开闭原则(Open Closed Principle)、里氏替换原则 (Liscov Substitution Principle)、

接口分离原则 (Interface Segregation Principle)、依赖倒置原则 (Dependency Inversion Principle)、

迪米特法则（Law of Demeter -> Least Knowledge Principle）、组合复用原则 (Composite/Aggregate Reuse Principle)



## 单一职责原则

核心思想：一个类，最好只做一件事，只有一个引起它变化的原因  

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052136444.png" alt="image-20230517113126103" style="zoom: 50%;" />

## 开闭原则（重要）

**对扩展开放，对修改关闭**。核心思想：面向抽象编程，而不是面向具体编程。

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052136552.png" alt="image-20230517113716004" style="zoom: 67%;" />

## 里氏替换原则（重要）

核心思想是：派生类必须能够替换其基类。类型适应。

表现：

1、派生类可以实现基类的抽象方法，实现多态（这就是C++中的虚函数的特点）

2、派生类可以增加自己的个性（C++中派生类可以新增新的特性）

3、但不能覆盖父类的非抽象方法（派生类中隐藏基类中的同名函数）

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052136235.png" alt="image-20230517114307174" style="zoom: 67%;" />

里氏代换原则是实现开闭原则的重要方式之一，由于在使用基类对象的地方都可以使用派生类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其派生类类型，用派生类对象来替换基类对象。

在运用里氏代换原则时**应该将基类设计为抽象类或者接口，让派生类继承基类或实现父接口**，并实现在基类中声明的方法，在运行时派生类实例替换基类实例，可以很方便地扩展系统的功能，无须修改原有派生类的代码，增加新的功能可以通过增加一个新的派生类来实现。



## 接口分离原则

核心思想：使用多个小的专门的接口，而不要使用一个大的总接口。

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052136496.png" alt="image-20230517115630221" style="zoom: 50%;" />

## 依赖倒置原则（重要）

核心思想：面向接口编程，依赖于抽象(抽象是**稳定的**，具体的是在变化的)

在实现依赖倒置原则时需要针对抽象层编程，而将具体类的对象通过依赖注入（DependenceInjection，DI）的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时采用抽象的形式来注入所依赖的对象。

常用的注入方式有3种，分别是构造注入、设值注入和接口注入。

- 构造注入是指通过构造函数来传入具体类的对象
- 设值注入是指通过Setter方法来传入具体类的对象；
- 接口注入是指通过在接口中声明的业务方法来传入具体类的对象。

这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。

**在大多数情况下，开闭原则、里氏代换原则和依赖倒置原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒置原则是手段**。

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052136993.png" alt="image-20230517120038499" style="zoom: 50%;" />



## 最少知识（知道）原则

降低类与类之间的耦合，减少类与类之间的关联程度。

迪米特法则要求在设计系统时应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中一个对象需要调用另一个对象的方法，可以通过“第三者”转发这个调用。简而言之，就是通过引入一个合理的“第三者”来降低现有对象之间的耦合度。

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052137596.png" alt="image-20230517120345946" style="zoom: 50%;" />

## 组合复用原则

尽量采用**组合、聚合**的方式而不是继承的方式来达到软件复用的目标。

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052137424.png" alt="image-20230517135335133" style="zoom: 50%;" />

# 设计模式

1、基本概念

它能提高程序员的**思维能力、编程能力和设计能力**。**它是解决特定问题的一系列套路，有一定的普遍性**。它是一套被反复使用、多数人知晓的、代码设计经验的总结。它可以提高代码的**可重用性、代码的可读性和代码的可靠性以及可扩展性**。它能使程序设计更加标准化，使软件开发效率提高，从而缩短软件的开发周期 。

2、分类

创建型模式（5种）：提供对象创建的机制，增加代码的灵活性和重用。（如何得设计更合理，但未必会更小）

结构型模式（7种）：解决如何将对象和类组装为更大的结构，同时保持结构的灵活性和高效性。

行为型模式（11种）：负责有效的沟通和对象之间的责任分配。

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052137115.png" alt="image-20231205213719237" style="zoom:80%;" />

​				    



## 简单工厂（静态工厂）

缺点：违反了对应的设计原则

1、违反了单一职责原则；2、违反了开放闭合原则测；3、违反了依赖倒置原则

优点：本工厂可以根据需求，产生各种各样的产品//简单工厂(静态工厂)

    https://gitee.com/boldness2012/cpp47_code/blob/master/20230419/figure.cc

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052137397.png" alt="image-20230517140825277" style="zoom: 67%;" />

使用场景
1、工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
2、客户端只知道传入工厂类的参数，对于如何创建对象并不关心  



## 工厂方法

改进：https://gitee.com/boldness2012/cpp47_code/blob/master/20230419/figure2.cc

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052137519.png" alt="image-20230517141239087" style="zoom: 67%;" />

应用场景
1、客户只知道创建产品的工厂名，而不知道具体的产品名。
2、创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。
3、客户不关心创建产品的细节，只关心产品的品牌  



## 抽象工厂

**抽象工厂生产抽象产品；抽象工厂要有具体工厂，抽象产品要有具体产品**。不同的具体工厂可能生产不同的具体产品。

抽象工厂接口中就确定了抽象产品的集合，如果要支持新种类的产品，就必须拓展抽象工厂的产品集合。那就涉及到抽象工厂类的及其子类的改变。

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052137974.png" alt="image-20230517141741793" style="zoom: 67%;" />

## 观察者模式

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052137468.png" alt="image-20230517141829154" style="zoom: 50%;" />

# 线程封装

## 面向对象的线程封装

https://gitee.com/demoCanon/cpp-gpt/tree/master/Solutions/thread_ES/OO_Thread

<p style="font-size:20px;font-weight: bold">类图</p>

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052137807.png" alt="image-20230519101506088" style="zoom: 67%;" />

<p style="font-size:20px;font-weight: bold">注意点1：threadFunc必须是静态的</p>

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052138539.png" alt="image-20230519103253124" style="zoom: 67%;" />

<p style="font-size:20px;font-weight: bold">注意点2：静态成员函数不能访问非静态成员</p>

线程执行任务：threadFunc是静态成员函数，而 run函数是非静态的，所以语法上面是会报错的。为了解决这个问题，有两种方法：

1. 将run设置为静态的（静态函数不能设置为虚函数）
2. 可以再构建一个指针，让该指针调用run方法，这个指针可以通过 threadFunc 的参数 args 传进来，而 args 是一个 nullptr 。
   所以需要将 pthread_create 的第四个参数设置为 **this** 指针。

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052138977.png" alt="image-20230519104105678" style="zoom: 67%;" />

**反思：** 需要时刻记住的是类是用来描述实体的特征与行为，基于特征与行为可以总结相关的用例，即成员函数的实现。在进行用例函数编写的时候，应当想一想，当进入这个用例函数时的条件是什么？离开这个用例函数的条件是什么？这个用例函数存在着什么约束限制？每个不用用例函数的前后关系是什么？

比如说 start函数，没有入口条件，如果非要有那只能是 isRunning 为false时，才能够pthread_create；但start函数只能是出现在第一次，所以可无入口条件。
而结束条件的关键点在于用例函数的核心点有没有完成，如果创建成功，那就更改isRunning 为true。

比如说 join函数，由于先后关系，isRunning 为 true，pthread_join的执行必须是在线程成功运行后进行的，那入口条件就是要判断isRunning ；结束条件就是完成pthread_join后，线程停止运行，更改isRunning 状态。

比如说 threadFunc函数，它的约束限制就是函数参数传来数据后，必须进行类型转换。入口条件就是判断传来的args是否是nullptr，不为nullptr方可进行线程的逻辑执行；如果为nullptr，不进行逻辑执行，直接线程退出。结束条件是不管线程有没有执行逻辑，都要结束pthread_exit。

比如说 ~Thread()，因为我们是分步骤执行start与join，但是很有可能出现还没有执行到join，线程已经执行完逻辑的时候。因此设置入口条件为当isRunning为true是才执行pthread_detach，因为只有join执行完了才会将isRunning置为false。

如果用例函数核心点没有完成，那函数只能是在报错的情况下返回而不执行后续代码。perror用于系统函数返回的错误自定义打印，如果自定义的函数返回可用printf自定义错误返回。

 如何区别入口条件、约束限制、结束条件？入口条件与结束条件是以用例函数的核心点进行围绕的，只有满足入口条件才可进行核心点执行；核心点执行结束或跳过后，结束条件的满足是为了更好辅助其他用例函数的执行或者让自身逻辑更合理。

## 基于对象的线程封装

https://gitee.com/demoCanon/cpp-gpt/tree/master/Solutions/thread_ES/BO_Thread

<p style="font-size:20px;font-weight: bold">类图</p>

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052138928.png" alt="image-20230519104320439" style="zoom: 67%;" />

<p style="font-size:20px;font-weight: bold">注意点1：线程注入的是一个函数对象</p>

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052138194.png" alt="image-20230519104927856" style="zoom: 67%;" />

<img src="../asset/image-20231205213847799.png" alt="image-20231205213847799" style="zoom:80%;" />

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052139163.png" alt="image-20231205213912096" style="zoom:80%;" />





# 生产者消费者封装

原理图：

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052139154.png" alt="image-20230519134806061" style="zoom: 50%;" />

## 面向对象生产者消费者封装

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052139614.png" alt="image-20230519134951165" style="zoom: 50%;" />

原本我的想法是各自new一个生产者消费者对象，将这两个对象传入工厂库中。可能这样想确实没毛病，但仔细想想工厂类就必须开通两个数据成员，那n个生产者消费者还得有n个数据成员？不合理！生产者消费者各自有着职责与权限，它们是可以操纵工厂进行工作。生产者消费者依赖于工厂，也就是任务队列。



# 线程池的封装

## 面向对象的线程池封装

线程池的开始与停止函数还能比较好写，但是功能函数ThreadsFunc却不知道从哪里开始，虽然知道要使用队列，但是不知道开始。这个时候你要想，队列的任务的类型还只是int型，那肯定是不行的。我们要自己定义一个任务类型。那这个任务类型有没有可能是基本数据类型，有可能，有没有可能是复合数据类型，有可能；有没有可能是函数对象的类型，有可能！那哪一个最稳当一些呢，函数对象类型，因为可以在函数对象里干更多的事情！包括做基本或者符合数据类型的操作。

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052139486.png" alt="image-20230520144552138" style="zoom:67%;" />

都知道要从任务队列里取任务，可是取到的任务又该怎么分配给线程池呢？哎呀我真是的是好笨。我能想到的就是遍历每一个线程如果线程空闲了就分配给它。

那么线程在执行完自己的任务后，首先就是不能退出，等待分配任务。那怎么等待呢？利用条件变量吗？那不应该如果如果获取不到任务那自然会。等一下乱了乱了，重新捋一下自己的问题。

1、线程的退出，我们肯定是希望线程执行完任务之后，先不退出，让其等待任务的分配，如果任务全都执行完了，那线程才可以跳出循环退出。这里不知道改作怎样的处理。

答：run方法会到threadsfunc函数中执行，在那里面去控制。并且线程退出的条件是任务队列里的任务都执行完了，所以要保证任务队列里的任务都是被取光了的，不能出现任务还没结束就退出，那执行join方法之前肯定是希望所有任务都被取完，那我判断的的条件就是任务队列还空不空，如果不为空就继续等待。不为空，再join等待子线程执行结束。在join之前有几种可能：要么都执行结束，要么都没执行结束，要么有的结束有的没结束。由于队列任务为空了各个子线程是无法继续循环的，都执行结束的肯定是陷入了睡眠，都没执行结束不要紧等待结束后是不会陷入睡眠的，接着唤醒操作，每个线程有序退出后，join就不会堵塞都得到来自exit的值后，主线程才继续往下执行。

2、从任务队列中获取的任务线程池又该怎么分配呢？遍历每一个线程如果线程空闲了就分配给它，但我不知道怎么操作。

对于线程池客户端来讲看到了任务类型，但任务是基类，对于基类中虚函数子类完成了重载，对外隐藏了具体信息。

3、 任务的执行完了后，怎么退出呢？优雅退出，。

