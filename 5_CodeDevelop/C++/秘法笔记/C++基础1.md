# 命名空间

## 为什么使用命名空间

当在同一个作用域中有两个或多个同名的实体，可能会出现名字冲突，为了解决命名冲突 ，C++中引入了 **命名空间**，所谓命名空间就是一个可以由用户自己定义的作用域，在不同的作用域中可以定义相同名字的变量，互不干扰，系统能够区分它们。存放在名字空间域中的全局实体只在本空间域内有效。

命名空间对全局实体加以域的限制，从而合理的解决命名冲突。

C++中定义命名空间的基本格式如下：

```c++
namespace CS
{
int val1 = 0;
char val2;
}// end of namespace CS
```

**定义在名称空间中的变量、函数、结构体、类等等统称为实体。而对命名空间的访问：命名空间+作用域限定符**。

名称空间中的实体作用域是全局的, 并不意味着其可见域是全局的。

如果不使用作用域限定符和 using 机制，抛开名称空间嵌套和内部屏蔽的情况，实体的可见域是从实体创建到该名称空间结束，而在名称空间外，该实体是不可见的。



## 命名空间的使用方式

命名空间一共有三种使用方式，分别是 using 编译指令、作用域限定符、using 声明机制。

### using 编译指令

using 编译指令，将标准命名空间 std 中的实体全部引出来。注意自定义的实体不要与标准命名空间 std 中的实体冲突

```c++
using namespace std;	//引入std实体

namespace CS
{
int number = 10;
void print() {
	cout << "void print()" << endl;//引入std可直接使用cout、endl
}

}//end of namespace CS

//自定义的实体与标准命名空间std中的实体冲突
void cout(){
    
}

```



### 作用域限定符

直接使用作用域限定符 `::` ，每次要使用某个名称空间中的实体时，都直接使用限定符引出。

```C++
namespace CS
{
int number = 10;
void display() {
    //cout,endl都是std空间中的实体，所以都要加上'std::'命名空间
    std::cout << "wd::display()" << std::endl;
}

}//end of namespace CS
```



### using 声明机制

using 声明机制的作用域是从 using 语句开始，到 using 所在的作用域结束。要注意，在同一作用域内用 using 声明的不同的命名空间的成员不能有同名的成员，否则会发生重定义。

**推荐使用的就是第三种，需要哪个实体的时候就引入到程序中，不需要的实体就不引入，尽可能减小犯错误的概率。**

```c++
#include <iostream>

using std::cout;	//需要哪个实体的时候就引入到程序中
using std::endl;	//需要哪个实体的时候就引入到程序中

namespace CS
{
int number = 10;
void display() {
    cout << "CS::display()" << endl;
}

}//end of namespace CS

using CS::number;
using CS::display;

int main(void) {
    cout << "CS::number = " << number << endl;
    CS::display();
}
```



## 匿名命名空间

不定义名字的命名空间称为匿名命名空间。由于没有名字，该空间中的实体，其它文件无法引用，它只能在本文件的作用域内有效，它的作用域是从匿名命名空间声明开始到本文件结束。

在本文件使用匿名空间成员时，不必用命名空间限定。其实匿名命名空间和 static 是同样的道理，都是只在本文件内有效，无法被其它文件引用。

```c++
int number = 10; //全局变量

namespace CS
{
int number = 20;
void print(int number) {
    cout << "形参number = " << number << endl;
    cout << "命名空间wd中的number = " << CS::number << endl;
    cout << "全局变量number = " << ::number << endl;	//匿名命名空间 
}

}//end of namespace
```

**在匿名空间中创建的全局变量，具有全局生存期，却只能被本空间内的函数等访问**，是 static 变量的有效替代手段。



## 命名空间的嵌套及覆盖

```c++
int number = 1;
namespace CS
{
int number = 10;
namespace CF
{
int number = 100;
void display() {
cout << "CS::wh::display()" << endl;
}
}//end of namespace CF
void display(int number) {
cout << "形参number = " << number << endl;
cout << "wd命名空间中的number = " << CS::number << endl;
cout << "wh命名空间中的number = " << CS::wh::number << endl;
}
}//end of namespace CS
int main(void) {
    using CS::display;
    display();
    return 0;
}
```


## 对命名空间的思考和总结

- 提倡在已命名的名称空间中定义变量，而不是直接定义外部全局变量或者静态全局变量。
- 如果开发了一个函数库或者类库，提倡将其放在一个名称空间中。
- 对于 using 声明，首先将其作用域设置为局部而不是全局。
- 不要在头文件中使用 using 编译指令，这样使得可用名称变得模糊，容易出现二义性。
- 包含头文件的顺序可能会影响程序的行为，如果非要使用 using 编译指令，建议放在所有#include 预编译指令后。



# const 关键字

##  const 关键字修饰变量

```c++
const int number1 = 10; // const关键字修饰的变量称为常量
int const number2 = 20;

const int val; // error，因为常量必须要进行初始化
```

除了这种方式可以创建常量外，还可以使用宏定义的方式创建常量

```
#define NUMBER 1024
```



## const 常量与宏定义的区别

- 编译器处理方式不同。宏定义是在预处理阶段展开，做字符串的替换；而 const 常量是在编译时。
- 类型和安全检查不同。宏定义没有类型，不做任何类型检查；const 常量有具体的类型，在编译期会执行类型检查。

在使用中，应尽量以 const 替换宏定义，可以减小犯错误的概率。



## const 关键字修饰指针

```c++
int number1 = 10;
int number2 = 20;

const int * p1 = &number1;	// 常量指针，做左向右读
*p1 = 100;	                // error:通过p1指针无法修改其所指内容的值
p1 = &numbers;	            // ok 可以改变p1指针的指向
int const * p2 = &number1;  // 常量指针的第二种写法

int * const p3 = &number1;	// 指针常量，const pointer
*p3 = 100;	                // ok 通过p3指针可以修改其所指内容的值
p3 = &number2;	            // error:不可以改变p1指针的指向

const int * const p4 = &number1;//两者皆不能进行修改
```

妙记：区分 **常量指针与指针常量**

- 当 const 位于 `*` 左边时，称为常量指针：`const *`

  ```c++
  const int *pstr = &number;	//const保护 *pstr ,不能改变指针所指对象的值，但可以改变指向
  ```

- 当 const 位于 `*` 右边时，称为指针常量：`* const`

  ```c++
  int * const pstr = &number;	//const保护 pstr ,不能改变指针的指向，但可以改变指向对象的值
  ```

  

## 数组指针与指针数组

```c++
// 数组指针(数组是个指针)
int (*pArray)[] //指向数组的指针
    
// 指针数组
int* pArray[]	//数字的元素是指针类型
```



## 函数指针与指针函数

函数指针：

```c++
int (*pf)(int);
```

指针函数：返回值类型是个指针，是个函数。

```c++
int* pf(int){
    
}
```



# new 和 delete 表达式

使用 new 表达式时发生的三个步骤：

1. 调用名为 operator new 的标准库函数，分配足够大的原始未类型化的内存，以保存指定类型的一个对象。
2. 运行该类型的一个构造函数初始化对象。
3. 返回指向新分配并构造的构造函数对象的指针。

使用 delete 表达式时发生的两个步骤：

1. 调用析构函数，回收对象中数据成员所申请的资源。
2. 调用名为 operator delete 的标准库函数释放该对象所指向的内存。

## 申请一个元素空间

**C++写法**：

```c++
int *pInt = new int(10);	//申请空间、初始化并赋值10
.....
delete pInt;		//回收空间
pInt = nullptr;		//防止野指针的问题

//如果之后在使用pInt，需要对pInt进行判空，这是一种规范
if( nullptr == pInt ){
    ...
} else{
    ...
}
```

C 写法：

```c
int *pInt = (int*)malloc(sizeof(int));
memset(pInt,0,sizeof(int)); // 初始化内存为0
....
free(pInt);
pInt = nullptr;
```

new 与 malloc 的对比：C 写法更详细一些，逻辑清晰；C++写法更简短一些。


## 申请堆空间数组

C++写法：

```c++
int *pArray = new int[10]();	// []中为初始化值
.....
delete [] pArray;				//[]中不需要写数字
```



## malloc 与 new 的异同点

不同点：

1. malloc/free 属于 c 语言的库函数，而 new/delete 是属于 C++中的表达式（它不是个库函数！）
2. malloc 申请的空间是原始的未初始化的，而 new 申请的空间是已初始化的（`()` 代表初始化）

相同点：都是用来申请堆空间的，都是需要成对出现的，否则会产生内存泄漏。

常见的内存问题：**内存泄漏、内存踩踏、踩内存、野指针**

内存泄漏：是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

内存溢出：指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存，导致无法运行程序。

内存踩踏：即内存重叠，是指访问了不合法的地址（访问了不属于自己的地址），如果访问的地址是其他变量的地址，就会破坏别人的数据，从而导致程序运行异常。

野指针：野指针是指向一个已经删除的对象或未申请访问受限内存区域的指针。



# 引用

引用的形式：

```c++
int number = 10;
int &ref = number;
```

如何区别引用与取地址呢？ 答：引用在定义前有类型。

## 引用的特征

引用就是变量的一个别名，对引用的修改操作就是对变量本身的修改，引用与变量指向的地址是相同的。

引用在定义时，必须要进行初始化，不能单独存在，必须要绑定上一个实体；并且引用一经绑定后，就不能改变绑定对象。

引用的底层实现就是一个指针（`* const`)，即 **指针常量**（不能改变自身的值，但可以改变指向的值）。

**C++中引入引用的目的，就是为了减少指针的使用。**



## 引用作为函数参数

一般的参数传递分为：值传递、地址传递、引用传递。

- 值传递：即产生一个副本数据、其本身具有拷贝开销。
- 地址传递：直观性不够友好。
- 引用传递：操作引用与操作变量本身的效果是一样的，直观性更好一些。

```c++
void swap(int &x,int &y);

//int &x = a; int &y = b;
```



## 引用作为函数的返回类型

函数的返回类型如果是引用的话，能够减少拷贝操作。因为函数的返回实则是将局部变量的值拷贝给使用者，也是存在拷贝开销的。

但注意的是正常函数内的局部变量是不能返回它的引用的，引用函数调用结束后，其声明周期也已经结束了。因此 **返回引用的前提：实体的生命周期一定要大于函数的生命周期**

```c++
int &getIndex(){
......
}
```


问题：如果在函数内申请堆空间，返回申请内存对象地址呢？

```c++
// 不建议这么做，因为会发生内存泄漏
int &getHeapData(){
	int *pInt = new int(10);
	return *pInt;
}

// 解决办法
int &ref = getHeapData();
delete &ref;//这样就可以解决堆空间返回引用时引起的内存泄露

```

所以正因为有这样的危险，在平时的代码编写中，不要写这样的代码，不然就需要别人对你写的代码进行内存回收的处理。

如果使用堆空间返回引用也不是不可以，如果能实现自动内存回收的话，这样的写法也是可以的。**所以在函数里申请堆空间时，推荐使用智能指针，完美解决内存泄漏！**



# 强制转换

与 C 强制转换的区别：C 的简单粗暴，C++这四种可以分场景，相对来说更安全，且容易在代码文件中查找 `grep -rn "static_cast" ./`

## static_cast（常用类型转换）

两种基本类型之间进行转换：

```c++
//float类型强转成int类型
iNumber = static_cast<int>(fNumber);
```

void* 和其他类型进行转换：

```c++
void* pret = malloc(sizeof(int));
int *pInt = static_cast<int*> (pret);
```

**`void*` 类型的数据在赋值给其他类型变量时，一定要进行类型转换。**

总结，static_cast 的用法主要有以下几种：
1. 用于基本数据类型之间的转换，如把 int 转成 char，把 int 转成 enum。这种转换的安全性也要开发人员来保证。
2. 把 void 指针转换成目标类型的指针，但不安全。
3. 把任何类型的表达式转换成 void 类型。
4. 用于类层次结构中基类和派生类之间指针或引用的转换。进行向上转换（把派生类的指针或引用转换成基类指针或引用）是安全的；而进行向下转换（将基类指针或引用转换为派生类指针或引用）时，由于没有动态类型检查，所以是不安全的。

## const_cast（向非常量类型转换）

const_cast：去除常量属性。常量指针被转化成非常量指针，并且仍然指向原来的对象；

```c++
//强转去除const的保护，number可被其他指针指向
const int number = 10;
int *pInt = const_cast<int*>(&number);

// 不要这样，语法报错：未定义行为
*pInt = 20;
```

## dynamic_cast

该运算符主要用于基类和派生类的转换，尤其是向下转型的用法中（基类对象转换为其派生类对象）。

## reinterpret_cast 

该运算符可以处理无关类型之间的转换，即用在任意指针（或引用）类型之间的转换，以及指针与足够大的整数之间的转换。由此可以看出，reinterpret_cast 的效果很强大，但错误的使用 reinterpret_cast 很容易导致程序的不安全，只有将转换后的类型值转换回到其原始类型，这样才是正确使用 reinterpret_cast 方式。

# 函数重载

函数重载（overload) 定义：在同一个作用域中，函数的名字相同，但是函数的参数列表不一样（参数的类型、参数的个数、参数顺序）。

```c++
int add(int a){
    return a;
}
int add(int a, int b){
    return a + b;
}
int add(int a, int b, int c){
    return a + b + c;
}
```

C 不支持函数重载，C++支持。C++支持的原因是因为支持对函数名与函数参数的改编（包括参数的顺序、参数的个数、参数的类型）。

linux 的 `nm` 命令：能够查看二进制文件的符号，下面为不同参数列表的 add 函数，因此 C++支持函数重载。

```c++
// c++编译
00000000000011c9 T _Z3addi
00000000000011d9 T _Z3addii
00000000000011f1 T _Z3addiii

// c编译
0000000000000000 T add
```

`n + shift + k` 直接在代码中查看 man 手册，n 为手册编号。

C++为何能使用 C 语言的库，历史原因：C++为了兼容 C，但是不能将所有 C 实现的库按照 C++方式进行，否则工程浩大，这样的兼容没有意义。所以对于 C 语言的库，要按照 C 的方式进行编译，即不进行名字改编。如果想将自己写的代码在 C++中按照 C 方式编译，可以使用 extern "C";

C++编程，中对某块区域进行 C 方式编译：

```c++
// 以C方式编译，使用extern将其包含
extern "c"
{
    ......
    ......
} // end of extern "C"
```

C 与 C++混合编程：这种比较安全，因为它考虑到文件是不是以 C++方式编译。能使 C 的源码既能够在 C 中以 C 的形式进行调用，也能在 C++中以 C 的形式进行调用，内置宏 `#ifdef __cplusplus  #endif`

```c++
#ifdef __cplusplus
extern "c"
{
#endif
...... //取决于C还是C++编译
......
#ifdef __cplusplus
}
#endif
```

# 默认参数

该函数定义时，某形参默认赋某值，即默认参数。若在一个函数里有 n 个参数，实参传入 a 个参数，则 n-a 个未传参数将使用默认参数默认值。

```c++
int add(int x,int y = 10,int z = 10);
```

注意：默认参数必须要从右往左设置参数默认值（连续的赋值，中间不可空着跳过）。

因为对于 C/C++而言，函数的参数入栈顺序就是从右向左。默认参数的使用是为了减少代码的书写，等价于多个不同的函数重载。



# bool 类型

一个 bool 类型只占用一个字节的大小。

```c++
int x = true;	=>1
int y = false;	=>0
```



# 内联函数

函数的调用是有开销的：需要在入栈出栈时，利用栈进行中转。但它的优势在于如果有 bug 能够及时在编译阶段发现其 bug。

带参数的宏定义即宏函数：宏定义发生的时机在预处理的阶段，进行字符串的替换，如果有 bug 需要在运行的时候才可以发现，但宏函数比函数调用效率高。

内联函数吸收函数调用与宏函数的优质特性，以宏的形式嵌入函数体。

```c++
inline int add(int x,int y){
    return x+y;
}
-------------------------------------------------
inline
int add(int x,int y);
#include"add.cc"
```

当函数调用的时候，可以用函数体替代函数的调用。

注意：内联函数不能分成头文件与实现文件的形式（不能将声明与实现分开），否则就会报错，在链接的时候链接不到。

如果一定要将头文件与实现文件分开写，可以在头文件中包含实现文件（ `#include"add.cc"` )

在头文件中 `#include "xxx.cc"` 可以将实现文件的名字改为 `xxx.tcc` 

> Tips:
> 
> 现代的编译器可以自动识别一个函数是不是内联函数，已经弱化了 inline 的使用效果。
> 
> 内联函数一般不建议使用 while for 等这种复杂语句，也不建议函数的嵌套使用。
> 
> 内联函数是以代码复制为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间相比于函数调用的开销较大，那么效率的收获会很小。另一方面，每一处内联函数的调用都要复制代码，将会使得程序的总代码量增大，消耗更多内存空间。



# 异常安全

异常是指程序在执行期间产生的问题。C++异常是指在程序运行时发生的特殊情况。异常提供了一种转移程序控制权的方式。C++异常处理涉及到三个关键字：try、catch、throw。

- throw：当问题出现时，程序会抛出一个异常。这是通过 throw 关键字完成的。
- try：try 块中的代码标识将被激活的特定异常，它后面通常跟着一个或多个 catch 块。
- catch：在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。

## throw 表达式

抛出异常即检测是否产生异常，在 C++中，其采用 throw 语句来实现，如果检测到产生异常，则抛出异常。格式为：`throw 表达式;` 

异常是一个表达式，其值的类型可以是基本类型，也可以是类。

## try-catch 语句块

```c++
try {
// 语句块
} 
catch(异常类型) {
// 具体的异常处理...
}

catch(异常类型) {
// 具体的异常处理...
}
```

try...catch 语句块的 catch 可以有多个，但至少要有一个。

try...catch 语句的执行过程是：
- 执行 try 块中的语句，如果执行的过程中没有异常拋出，那么执行完后就执行最后一个 catch 块后面的语句，所有 catch 块中的语句都不会被执行；
- 如果 try 块执行的过程中拋出了异常，那么拋出异常后立即跳转到 **第一个“异常类型”和拋出的异常类型匹配的 catch 块中执行**（称作异常被该 catch 块“捕获”），执行完后再跳转到最后一个 catch 块后面继续执行。

```c++
try{
    if(0 == y){
        throw y; //抛出异常
    } else {
        cout<< "x+y = "<< x/y <<endl;
    }
}
catch(int x){
    cout<<"catch(int)"<<endl;
}
catch(double y){
    cout<<"catch(double)"<<endl;
}
```


# C/C++风格字符串

## C 定义字符串形式

字符数组：与 `*const` 指针常量的效果是一样的

```c++
//无法改变指针指向，却能通过指针修改指向对象的值
char str1[] = "hello";
```


字符指针：与 `const*` 常量指针的效果是一样的

```c++
//可以改变指针的指针，但是无法通过指针修改指向对象的值，常用const保护修饰
const char *pstr = "chinese";
```

**获取字符串长度**：sizeof 是获取字节大小的，连 `\0` 是包括在内的；strlen 只计算字符串的长度、不包含 `\0` 。

```c++
size_t len1 = sizeof(str1);	// 6个字节内存
size_t len2 = strlen(str1);	// 长度为5

size_t len3 = sizeof(pstr);	// 8个字节内存
size_t len4 = strlen(pstr);	// 长度为7
```

测试指针大小的时候，不要使用 sizeof，因为 sizeof 只与系统相关，与指针类型是没有关系的，如下例子：

```c++
int *pInt;
size_t len5 = sizeof(pInt);	//虽然没有初始化，但输出结果是8
```



## C++定义字符串形式

C++定义字符串的时候，不要忘记添加头文件 `<string>`

1. **字符串的定义**（C 风格向 C++转变）

   ```C++
   string s1 = "hello";
   string s2 = "world";
   string s3 = s1 + s2;	//与C的区别是不需要考虑与内存相关的操作，直接拼接 s3 = "helloworld"
   ```

2. **将 C++风格转变为 C** （使用 `c_str()` )

   ```c++
   const char *pstr = s3.c_str();	//s3调用函数
   ```

3. **获取 C++字符串的长度** （使用 length 与 size 没有区别，都是计算长度）

   ```c++
   size_t len1 = s3.length();	//10
   
   size_t len2 = s3.size();	//10
   ```

4. **遍历 C++风格字符串**

   ```C++
   for(size_t idex = 0; idx != s3.size(); ++idx){
   	.....
   }
   ```

5. **C++风格字符串的拼接** （有三种形式）

   ```c++
   //以下三种形式都是OK的 
   string s4 = s3 + "kexue";	//后接字符串
   string s5 = s3 + 'A';		//后接字符
   s5.append(s1);				//调用append函数
   ```

   

# C++ 内存分配方式

以 32 位的系统为例，$2^{32}$  = 4G  ，分配 4G 的地址空间（虚拟内存）, Linux 默认将高地址的 1G 空间分配给内核，用户使用剩下的 3G 空间成为用户态空间。

! [[程序内存布局.png]]

**3G — 4G：**  内核空间

**0   — 3G：**  用户态空间

**栈区：** 存放栈变量、栈对象、局部变量、函数参数、函数返回地址等。**编译器进行自动分配与释放**。

**堆区：** malloc / calloc / new 申请的空间都是堆空间。需要程序员进行申请与释放，如果程序员不回收，OS 可能会进行回收。

**全局静态区（读写区）：** 全局变量：初始化与未初始化   ；静态变量：初始化与未初始化，static 作修饰

**只读区：** 文字常量区：存放字符串常量；	程序代码区：程序的二进制代码。

用户态空间一般有如下默认区域：

1. 栈区(stack)：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。
2. 堆区(heap)：一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
3. 全局/静态区(static）：全局变量和静态变量的存储是放在一块的，在程序编译时分配。
4. 文字常量区：存放常量字符串。
5. 程序代码区：存放函数体（类的成员函数、全局函数）的二进制代码。

## 栈与堆的比较

申请后系统的响应
- 栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。
- 堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，对于大多数系统，首地址处会记录这块内存空间中本次分配的大小，这样，代码中的 delete 语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

申请效率的比较：
- 栈由系统自动分配，速度较快。但程序员无法控制。
- 堆是由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。

申请大小的限制：
- 栈：在 Windows 下, 栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（也有的说是 1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。
- 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。。由此可见，堆获得的空间比堆的大小受限于计算机系统中有效的虚拟内存较灵活，也比较大。

堆和栈中的存储内容：
- 栈： 在函数调用时，第一个进栈的是主函数的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。
- 堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。

## 栈与堆的区别

栈与堆的区别在一下六个方面有所不同：

1. 管理方式不同。对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生 memory leak。
2. 空间大小不同。一般来讲在 32 位系统下，内存可以达到 4G 的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在 VS 下，默认的栈空间大小是 1M。
3. 分配方式。内存有 2 种分配方式：静态分配和动态分配。堆都是动态分配的，没有静态分配的堆。静态分配是编译器完成的，比如局部变量的分配。动态分配由 malloc, calloc 函数进行分配，但是栈的动态分配和堆是不同的，栈的动态分配是由编译器进行释放，无需我们手动实现。
4. 生长方向。对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。
5. 碎片问题。对于堆来讲，频繁的 new/delete 势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在它弹出之前，在它上面的后进的栈内容已经被弹出。
6. 生长方向。对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。

