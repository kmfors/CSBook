# 友元

## 基本概念

面向对象四大基本特征：抽象、封装、继承、多态。

友元可以打破封装性的特点。

```C++
class 类名A
{
    friend 函数的原型;//可以是成员函数也可以是非成员函数
    friend class B;
};
```

函数：可以分为成员函数与非成员函数。

非成员函数：全局函数、自由函数、普通函数。

注意：

```c++
// 当定义一个空类时，没有数据成员，是一个不完整类型
Point pt;	// 不完整类型是不能创建对象的
Point *ppt;	// 不完整类型是可以创建指针的
```



## 友元的性质

类中的**私有成员**被声明为private类型，只有被类里的成员函数访问，在类外是不能访问的。

缺点：偶尔类外想访问私有成员，会既访问不到，又不能声明为public类型。友元的出现可以很好的解决这一问题
                      
友元的作用：在类外想要访问一个类的私有成员，可以**将访问的私有成员声明为友元类型，友元类型的私有成员我们则有权利访问了**。

友元的意义：单独开辟一条绿色通道，供其访问私有成员

友元：

1. 友元(全局)函数 friend ：**你是我信任的网友，我允许你知道我的秘密；函数在类外定义，在类中声明，同时声明用friend修饰，意为信任人
2. 友元类：**你一家人是我的好朋友，我允许你家里人知道我的秘密；定义一个朋友类(有函数),在我的类中声明一下朋友类，用friend修饰，意为朋友
3. 友元成员函数：**你一家人是我好朋友，但我只允许你知道我的秘密**

**注意事项：**

1. 友元关系不能被继承
2. 友元关系是单向的，类A是类B的朋友，但类B不一定就是类A的朋友
3. 友元关系不具有传递性。类B是类A的朋友 ，类C是类B的朋友，但类C不一定是类A的朋友

**Tips：友元的声明是不受public/protected/private关键字限制的。****



## 友元普通函数

友元的第一种形式：[[秘法笔记#友元之普通函数|友元之普通函数]]（自由函数、全局函数）

普通函数想要访问类的私有成员，先在类内进行自我的函数声明用friend修饰。即可在普通函数体内用实例访问类的私有成员了。

普通函数体内访问类的私有成员不限于以下几种方式：形参的指针、引用，局部实例




## 友元类

友元的第二种形式：[[秘法笔记#友元之友元类|友元之友元类]]

在别的类中声明为友元的类，类内可任何形式访问别的类的私有成员。



## 友元成员函数

友元的第三种形式：[[秘法笔记#友元之友元成员函数|友元之友元成员函数]]

只能让其他类的部分函数访问类的私有成员。



# 运算符重载

## 基本概念

C++预定义中的运算符的操作对象只局限于基本的内置数据类型，但是对于我们自定义的类型是没有办法操作的。但是大多时候我们需要对我们定义的类型进行类似的运算，这个时候就需要我们对这么运算符进行重新定义，赋予其新的功能，以满足自身的需求。

为了使对用户自定义数据类型的数据的操作与内置数据类型的数据的操作形式一致，C++提供了运算符的重载,通过把C++中预定义的运算符重载为类的成员函数或者友元函数，使得对用户的自定义数据类型的数据(对象)的操作形式与C++内部定义的类型的数据一致。

运算符重载的实质就是**函数重载**或**函数多态**。运算符重载是一种形式的 C++ 多态。目的在于让人能够用同名的函数来完成不同的基本操作。要重载运算符，需要使用被称为运算符函数的特殊函数形式，运算符函数形式：

```c++
返回类型 operator 运算符(参数表)
{
    //...
}
```

operator无需类声明！



## 运算符重载的规则

运算符重载具有以下规则：

1. 为了防止用户对标准类型进行运算符重载，C++规定重载的运算符的操作对象必须至少有一个是自定义类型或枚举类型
2. 运算符重载的时候，不能改变优先级与结合性
3. 运算符重载的时候，不能改变操作数的个数、不能改变操作数顺序，当然肯定不能设置默认值。
4. 不能臆造不存在的运算符，例如：$、@
5. 重载逻辑运算符（&&,||）后，不再具备短路求值特性  



### 不能重载的运算符

- 成员访问运算符 `.`
- 成员指针运算符 `*`
- 三目运算符 `?:`
- 作用域限定符 `::`
- sizeof运算符：如果 sizeof() 是一个函数的话，那么肯定需要使用参数列表。

### 可以重载的运算符

![image-20250120214259447](/1_store/1_asset/image-20250120214259447.png)



## 运算符重载的形式

运算符重载的形式有三种：

- 采用普通函数的重载形式
- 采用成员函数的重载形式
- 采用友元函数的重载形式

### 以普通函数形式重载

运算符重载的第一种形式：运算符重载之普通函数的形式。（**需要有get函数做支撑**）。[[秘法笔记#运算符重载（普通函数形式）|示例代码]] ，为什么需要get函数呢？因为无法直接访问私有成员进行操作。

运算结果：

```shell
Complex(double = 0, double = 0)
c1 = 1 + 2i

Complex(double = 0, double = 0)
c2 = 3 + 4i

Complex operator+(const Complex &, const Complex &)
Complex(double = 0, double = 0)
c3 = 4 + 6i
~Complex()
~Complex()
~Complex()
```



### 以成员函数形式重载

运算符重载的第二种形式：成员函数的形式（形参少一个参数）。好处：方便使用，不需要调用get函数。[[秘法笔记#运算符重载（成员函数形式）|示例代码]]

运行结果：

```shell
Complex(double = 0, double = 0)
c1 = 1 + 2i

Complex(double = 0, double = 0)
c2 = 3 + 4i

Complex operator+(const Complex &, const Complex &)
Complex(double = 0, double = 0)
c3 = 4 + 6i
~Complex()
~Complex()
~Complex()
```



### 以友元函数形式重载（推荐）

如果以友元函数形式进行重载，同样不需要定义get函数：

运行结果：

```shell
Complex(double = 0, double = 0)
c1 = 1 + 2i

Complex(double = 0, double = 0)
c2 = 3 + 4i

Complex operator+(const Complex &, const Complex &)
Complex(double = 0, double = 0)
c3 = 4 + 6i
~Complex()
~Complex()
~Complex()
```



## 特殊运算符的重载

### 复合赋值运算符的重载

以成员函数的形式进行重载，对于**对象本身发生变化的这种运算符，一般建议使用成员函数的形式进行重载**。

复合赋值运算符： `+=   -=    *=    /=    %=   <<=	>>=`

```c++
c2 += c1; //等价于c2.operator+=(c1); 
```


![image-20250120214441794](/1_store/1_asset/image-20250120214441794.png)

注意：返回的是对象，所以会创建一个匿名对象，数据拷贝结束后，匿名对象调用析构销毁。赋值运算符函数重载要考虑深拷贝的问题。
![image-20250120214453748](/1_store/1_asset/image-20250120214453748.png)





### 自增自减运算符的重载

自增运算符++和自减运算符--**推荐以成员函数形式重载**，分别包含两个版本，即运算符前置形式(如 ++x)和运算符后置形式(如 x++)。

二者操作不一样，需要在对这两个运算符进行重载区分前置和后置形式。

C++根据参数的个数来区分前置和后置形式。如果按照通常的方法（成员函数不带参数）来重载++/--运算符，那么重载的就是前置版本。

要对后置形式进行重载，就必须为重载函数再增加一个int类型的参数，该参数仅仅用来告诉编译器这是一个运算符后置形式，在实际调用时不需要传递实参。

#### 前置运算符重载：

```c++
++c2; //等价于c2.operator++();
```

![image-20250120214525810](/1_store/1_asset/image-20250120214525810.png)

#### 后置运算符重载：

```c++
c2++ ; //等价于c2.operator++(10)，括号里随便写一个整数
```



![image-20250120214548914](/1_store/1_asset/image-20250120214548914.png)

### 输入输出流运算符重载

注意：**不能将输入输出流运算符以成员函数的形式进行重载，要以友元函数进行重载**

如果将输出流运算符函数以成员函数的形式进行重载，那么就必须满足两个参数的要求，所以需要将Complex类型的对象用this指针进行替代。
但是这样就会改变流对象os与Complex对象的位置，这样就违背了运算符重载的规则，不能改变操作的位置，所以就不能将输出流运算符以成员函数的形式进行重载。

对于运算符重载而言，要确定函数的名字（这个比较简单），然后需要确定函数的参数列表，最后确定函数的返回类型。[[秘法笔记#输入输出流运算符重载|示例代码]]




### 重载小括号（函数调用运算符）

了解什么是函数对象

注意：将重载了函数调用运算符的类创建的对象称为函数对象。[[秘法笔记#重载小括号|示例代码]]




### 重载中括号(下标访问运算符）

特征：下标访问运算符的重载可以让程序更加安全点。[[秘法笔记#重载中括号|示例代码]]

**引用符号什么时候需要加上？**

1、如果函数的返回值的生命周期比函数的生命周期大的时候，为了避免在执行return语句的时候多执行一次拷贝操作，所以尽量使用引用

2、在流中，是可以无限传递参数执行下去，这个时候用引用可以减少多次拷贝，提高程序的执行效率

3、在赋值运算符函数的返回类型的时候，也是返回的引用，因为连等的时候，可以少执行拷贝操作，也可以提高程序的执行效率



### 成员访问运算符的重载

箭头访问运算符`->`重载、解引用运算符`*`重载。[[秘法笔记#成员访问运算符的重载|示例代码]]



## 运算符重载总结

对于运算符重载时采用的形式的建议：

- 所有的一元运算符，建议以成员函数重载

- 运算符 = () [] -> * ，必须以成员函数重载

- 运算符 `+= -= /= *= %= ^= &= != >>= <<=` 建议以成员函数形式重载

- 其它二元运算符，建议以非成员函数重载



## 函数对象

注意：将重载了函数调用运算符的类创建的对象称为函数对象

```c++
template <typename T>
struct CompareList
{
    bool operator()(const T &lhs, const T &rhs) const
    {
        cout << "bool operator()(const T &, const T &) const" << endl;
        return lhs < rhs;
    }
};
//每次使用时，CompareList com
// com(lhs,rhs) 等价于 com.operator()(lhs,rhs)
```



# 类型转换

前面介绍过对普通变量的类型转换，比如说 int 型转换为long型，double型转换为int型，接下来要讨论下类对象与其他类型的转换。

转换的方向有:

- 由其他类型向自定义类型转换
- 由自定义类型向其他类型转换



## 隐式转换

**从其他类型向自定义类型进行转换**，实质上发生的就是隐式转换，而隐式转换需要有自定义类型的构造函数做支撑。
![image-20250120214623451](/1_store/1_asset/image-20250120214623451.png)


`std::string s1 = "hello,world";` 该语句时，这里其实是有隐式转换的，但该隐式转换的执行很自然，很和谐。而上面把一个int型数据直接赋值给一个Point对象，看起来就是比较诡异的，难以接受，所以这里我们是不希望发生这样的隐式转换的。那怎么禁止隐式转换呢？

比较简单，只需要在相应构造函数前面加上**explicit**关键字就能解决。



## 类型转换函数

**由自定义类型向其他类型的转换**是由**类型转换函数**完成的，这是一个特殊的成员函数。它的形式如下：

```c++
operator 目标类型()
{
	//...
}
```

类型转换函数具有以下的特征:

- 是成员函数
- 函数没有返回类型
- 函数没有参数列表
- 靠 return 语句返回目标类型的变量

[[秘法笔记#类型转换函数|示例代码]]


# 类域

作用域可以分为**类作用域**、**类名的作用域**以及**对象的作用域**几部分内容。在类中定义的成员变量和成员函数的作用域是整个类，这些名称只有在类中（包含类的定义部分和类外函数实现部分）是可见的，在类外是不可见的，因此，可以在不同类中使用相同的成员名。另外，类作用域意味着不能从外部直接访问类的任何成员，即使该成员的访问权限是public，也要通过对象名来调用，对于static成员函数，要指定类名来调用。

如果发生“屏蔽”现象，类成员的可见域将小于作用域，但此时可借助this指针或  “ 类名:: ”   形式指明所访问的是类成员，这有些类似于使用::访问全局变量。

```c++
#include <iostream>
using std::cout;
using std::endl;

int num = 1;
namespace CS
{
int num = 20;
class Example {
public:
    void print(int num) const {
        cout << "形参num = " << num << endl;
        cout << "数据成员num = " << this->num << endl;
        cout << "数据成员num = " << Example::num << endl;
        cout << "命名空间中num = " << CS::num << endl;
        cout << "全局变量num = " << ::num << endl;
    }
private:
    int num;
};

}//end of namespace wd
```

和函数一样，类的定义没有生存期的概念，但类定义有作用域和可见域。使用类名创建对象时，首要的前提是类名可见，类名是否可见取决于类定义的可见域，该可见域同样包含在其作用域中，类本身可被定义在3种作用域内，这也是类定义的作用域。

## 作用域与可见域

作用域与可见域的区别：如果没有发生屏蔽现象，那么作用域等于可见域。参考上例的数据成员打印。

## 内部类

将一个类的定义放在另外一个类中。

## 设计模式：Pimpl模式

PIMPL是通过一个私有的成员指针，将指针所指向的类的内部实现数据进行隐藏。PIMPL又称作“编译防火墙”，它的实现中就用到了嵌套类。

PIMPL设计模式有如下优点：

1. 提高编译速度；
2. 实现信息隐藏；
3. 减小编译依赖，可以用最小的代价平滑地升级库文件；
4. 接口与实现进行解耦；
5. 移动语义友好。

1.0版本代码：优势是代码量少；劣势是不够封装性，能看到具体实现细节，内部类与主类的耦合性太强，后期不易更改。

2.0版本代码：对比1.0多了一层嵌套的内部类外包，但是在主类中隐藏了具体实现细节，降低了与主类的耦合，后期易维护。

https://gitlab.com/kmfors/collectbox/-/tree/main/cpp/PointToLine  有两个版本的，2.0版本是Pimpl模式

## 单例模式的自动释放

检测内存泄漏的工具valgrind

```shell
" 安装方式：
$ sudo apt install valgrind
" 使用方式:
$ valgrind --tool=memcheck --leak-check=full ./test
```



设计1：友元实现单例对象的自动释放

设计2：内部类加静态数据成员形式

由于单例对象的数据成员是静态，因此设计1与设计2不管是通过友元类还是内部类，都是通过自身的消亡来实现单例对象的自动释放，但不够优雅。

设计3：atexit方式 + 饿汉模式（程序启动时进行对象的实例化）：但线程不安全

设计4：pthread_once形式

https://gitlab.com/kmfors/collectbox/-/tree/main/Backbox/cpp_base/SingletonAutoRelease



# string的底层实现

## 深拷贝（浅拷贝）

最简单的就是深拷贝了。无论什么情况，都是采用拷贝字符串内容的方式解决，这也是我们之前已经实现过的方式。这种实现方式，在需要对字符串进行频繁复制而又并不改变字符串内容时，效率比较低下。所以需要对其实现进行优化，之后便出现了下面的COW的实现方式。

## 写时复制

COW(Copy-On-Write)：**浅拷贝 + 引用计数**。

当进行读操作的时候，只是进行浅拷贝操作，并记录对象的个数；当进行写操作的时候，才去进行深拷贝，效率提高。（ubuntu1404版本使用的是写时复制）

```shell
# 查看ubuntu版本的命令
lsb_release -a
```



## 短字符串优化（sso）

当字符串的长度小于16字节的时候，申请在**栈上**；当字符串的长度大于等于16的时候，申请在**堆上**。(在ubuntu1804上使用短字符串优化sso)

```c++
&pInt = 0x7ffe026c8738
s1 =    0x7ffe026c8750
s2 =    0x7ffe026c8770
s3 = 	0x556aaf3fae90
&pInt = 0x7ffe026c8738
pInt = 0x556aaf3fae70
s3 =   0x556aaf3fae90
```



## 写时复制的实现

引用计数存在于哪里？

- 如果放在栈上，在执行拷贝构造函数的时候，两个字符串里的引用计数都要加1，可问题是传入的字符串是用const修饰，无法进行引用计数的加1，如果去掉const修饰，又会有传入右值的风险问题。
- 如果是静态变量，所有string类对象都共享这个引用计数，但我们希望引用计数使用在引用同一个位置的计数，定义不同的字符串会导致cnt也加1

放在堆里最合适，将其与数据放在一起，并且最好可以放在数据的前面，以便于更好的获取该引用计数。

https://gitlab.com/kmfors/collectbox/-/tree/main/Backbox/cpp_base/Cowstring



# 面向对象程序设计

面向对象的4大基本特征：抽象、封装、继承、多态。

1. **封装（Encapsulation）：** 封装是将数据（属性）和操作（方法）捆绑在一起形成类（或对象），并对外部隐藏对象的内部细节。通过封装，对象的内部实现细节被保护起来，只有通过对象的公共接口才能访问和操作对象的状态和行为。
2. **继承（Inheritance）：** 继承是一种机制，它允许一个类（称为子类或派生类）基于另一个类（称为父类或基类）来创建，并且子类继承了父类的属性和方法。通过继承，子类可以复用父类的代码，并且可以在不修改父类的情况下扩展或修改其行为。
3. **多态（Polymorphism）：** 多态性是指相同的操作或方法在不同的对象上可以表现出不同的行为。它允许一个函数或方法根据接收到的对象类型而表现出不同的行为。多态性提高了代码的灵活性和可扩展性，并且是实现多态行为的关键机制包括函数重载、运算符重载和虚函数。
4. **抽象（Abstraction）：** 抽象是将对象的共同特征提取出来形成类的过程，它忽略了不必要的细节，只关注于对象的关键特征和行为。通过抽象，可以定义出具有通用性和可重用性的类和接口，从而降低了系统的复杂度并提高了代码的可维护性和可扩展性。

# 继承

## 继承的定义

继承是一种机制，它允许一个类（称为子类或派生类）基于另一个类（称为父类或基类）来创建，并且子类继承了父类的属性和方法。通过继承，子类可以复用父类的代码，并且可以在不修改父类的情况下扩展或修改其行为。

当一个派生类继承一个基类时，需要在派生类的类派生列表中明确的指出它是从哪个基类继承而来的。

类派生列表的形式是在类名之后，大括号之前用冒号分隔，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问修饰限定符，其形式如下:

```c++
class 派生类 : public/protected/private 基类
{ 
    //***
};
```

派生类生成过程：
- 吸收基类成员
- 改造基类成员
- 添加自己新的成员

继承的局限：无论何种继承方式，下面这些基类的特征是不能从基类继承下来的
- 构造函数、析构函数
- 用户重载的operator new/delete运算符、operator =运算符
- 友元关系

## 访问权限

**派生方式对基类成员的访问权限：**
![image-20250120214810852](/1_store/1_asset/image-20250120214810852.png)


通过继承，除了基类私有成员以外的其它所有数据成员和成员函数，派生类中可以直接访问。

private成员是私有成员，只能被本类的成员函数所访问，派生类和类外都不能访问。

public成员是公有成员，在本类、派生类和外部都可访问。

protected成员是保护成员，只能在本类和派生类中访问，是一种区分血缘关系内外有别的成员。

总结：派生类的访问权限规则如下：

1. 不管以什么继承方式，派生类内部都不能访问基类的私有成员。
2. 不管以什么继承方式，派生类内部除了基类的私有成员不可以访问外，其他的都可以访问。
3. 不管以什么继承方式，**派生类对象**只能访问公有继承基类中的公有成员，其他的一律不能访问

**注意：如果不写继承方式，那么默认的继承方式都是私有的**。



## 派生类对象的构造

原则：先构造基类部分，后构造派生类部分。

错误的说法是：派生类对象的构造是“先调用基类的构造函数，然后调用派生类的构造函数”。

**为了完成从基类吸收过来的数据成员的初始化，需要在派生类的构造函数的初始化列表中，借助基类的构造函数完成吸收过来的数据成员的初始化**。

```c++
派生类的构造函数名(参数列表) 
: 基类的构造函数(基类构造函数的参数列表)
{
    //派生类的构造函数的函数体
}
```

对于派生类对象的构造，我们分下面4种情况进行讨论：

1. 如果派生类有显式定义构造函数，而基类没有显示定义构造函数，则创建派生类的对象时，派生类相应的构造函数会被自动调用，此时都自动调用了基类缺省的无参构造函数。
2. 如果派生类没有显式定义构造函数而基类有显示定义构造函数，则基类必须拥有默认构造函数。
3. 如果派生类有构造函数，基类有默认构造函数，则创建派生类的对象时，基类的默认构造函数会自动调用，如果你想调用基类的有参构造函数，必须要在派生类构造函数的初始化列表中显示调用基类的有参构造函数。
4. 如果派生类和基类都有构造函数，但基类没有默认的无参构造函数，即基类的构造函数均带有参数，则派生类的每一个构造函数必须在其初始化列表中显示的去调用基类的某个带参的构造函数。如果派生类的初始化列表中没有显示调用则会出错，因为基类中没有默认的构造函数。

Tips:
1. 创建派生类对象的时候，会调用派生类的构造函数，但是派生类是继承基类基类的，所以会吸收基类的数据成员。为了完成从基类这边吸收过来的数据成员的初始化，会借鉴基类的构造函数，完成从基类吸收过来的数据成员的初始化，然后再执行派生类的构造函数的函数体。
2. 如果派生类没有显式定义构造函数而基类有显示定义构造函数，则基类必须拥有默认构造函数 ，因为派生类的构造函数会默认调用基类的默认（无参）构造函数。目的：就是为了完成吸收的数据成员的初始化。

总结：在创建派生类对象的时候，为了完成从基类吸收过来的数据成员的初始化，需要使用基类的构造函数，那么最好可以**手动在派生类的初始化列表中将基类的构造函数显示的调用出来**，这样可以保证代码不出错。

**派生类构造函数的调用顺序：**

1. 完成对象所占内存的开辟。
2. 调用基类的构造函数，完成从基类吸收的数据成员的初始化。
3. 完成子对象、const数据成员、引用数据成员的初始化。
4. 执行派生类构造函数的函数体。


## 派生类对象的销毁

当派生类对象被删除时，派生类的析构函数被执行。析构函数同样不能继承，因此，在执行派生类析构函数时，基类析构函数会被自动调用。执行顺序是先执行派生类的析构函数，再执行基类的析构函数，这和执行构造函数时的顺序正好相反。

派生类对象在销毁的时候（离开作用域的时候），会执行派生类自己的析构函数（完成派生类自己数据成员的清理操作）。然后，当派生类的析构函数执行完成之后，**基类的析构函数会被自动调用**。

当考虑对象成员时，继承机制下派**生类析构函数的调用顺序：**

1. 先调用派生类的析构函数
2. 再调用派生类中成员对象的析构函数
3. 最后调用普通基类的析构函数



## 多基派生（多继承）

派生类继承基类的时候，如果是多继承，那么**多个基类的构造函数的执行顺序只与多个基类被继承的先后顺序有关**，与基类的构造函数在派生类的初始化列表中的先后位置没有关系。对于多继承而言，每个基类的前面都要写继承方式，否则就按照默认的私有进行继承。

**菱形继承**：如果有两个派生类继承了同一个基类，然后又有一个类同时继承这两个派生类，这种继承我们称之为：菱形继承，或者钻石型继承。

​		  A                		             Person

​	B	     	C         		 Singer                   Waiter

​		  D                  		      SingingWaiter

菱形继承带来的问题：

1. Singer与Waiter分别继承了Person的成员；当SingingWaiter访问Person成员时，会产生二义性。（**成员名冲突的二义性**）
2. SingingWaiter继承来自Person的数据有两份，浪费内存。（**菱形继承的二义性**）

### 成员名冲突的二义性

一般来说，在派生类中对基类成员的访问应当具有唯一性，但在多基继承时，如果多个基类中存在同名成员的情况，造成编译器无从判断具体要访问的哪个基类中的成员，则称为对基类成员访问的二义性问题。

解决办法：多基继承（多基派生）成员函数访问冲突时请使用：使用类名 + 作用域限定 进行指定访问。通过作用域，访问具体的类的成员。缺点：会继承两份数据，浪费内存。

```c++
// 人类
class Person {
public:
	int m_Age;	// 年龄
};

class Singer :public Person {

};

// 服务员类
class Waiter :public Person {

};

// 唱歌的服务员
class SingingWaiter : public Singer, public Waiter {

};
------------------------------------------
// 创建一个SingingWaiter的对象
SingingWaiter sw;

// 问题1： 访问同名成员产生的二义性
sw.m_Age = 200; //报错！该变量不明确！不知道你要访问的是哪一类的人的年龄

sw.Singer::m_Age = 20;  // 通过作用域，访问具体的类的变量
sw.Waiter::m_Age = 30;
	
```


### 菱形继承的二义性

多基派生中，如果在多条继承路径上有一个共同的基类。那样会继承两份相同的基类数据，浪费内存。

解决方式：采用虚继承机制，**虚继承，子类加上virtual后就是虚继承，而父类被称为虚基类。**

原理：只有一个唯一的成员，通过保存虚基类指针，这个指针指向的是一张表（虚基类表）。这个表中保存了当前获取到唯一的数据的偏移量。

```c++
class Person {
public:
	int m_Age;	// 年龄
};

// 歌手类  加上virtual后就是虚继承，Person类被称为虚基类。
class Singer :virtual public Person {

};

// 服务员类
class Waiter :virtual public Person {

};

// 唱歌的服务员
class SingingWaiter : public Singer, public Waiter {

};
-----------------------------------------------------
sw.m_Age = 200; //正确，不报错！ m.Age会被两个类所继承
```


![image-20250120214900518](/1_store/1_asset/image-20250120214900518.png)

vbptr: virtual base pointer(虚基类指针)




## 基类与派生类间的相互转换

类型适应，是指两种类型之间的关系，说 A类适应 B类是指 A类的对象能直接用于 B类对象所能应用的场合。因此从这种意义上讲，基类不适应于派生类，但派生类适应于基类，由此推理派生类对象适应于基类对象，派生类对象的指针和引用也适应于基类对象的指针和引用。

从而，**类型适应具体是指，派生类对象是可以适用于基类对象**，场景有：

- 可以将派生类的对象赋值给基类的对象
- 可以将基类引用绑定到派生类的对象
- 可以声明基类指针指向派生类的对象 (向上转型)

也就是说如果函数的**形参**是基类对象或其对象引用或其对象指针的类型，在进行**函数调用**时，相应的**实参**可以是派生类对象或其引用或其指针。[[秘法笔记#基类与派生类的类型转换|代码实例]]

运行结果如下：

```shell
# 向下转型（基类转派生类）
Base::_base = -858993460
Derived::_derived = -858993460

Base::_base = -858993460
Derived::_derived = 40
```

向上转型：从派生类向基类进行转换，都是可以的。
向下转型：从基类向派生类进行转换，本来语法是不支持的，但是C++支持强转，所以又支持了。但是向下转型存在不安全性。（有安全的，也有不安全的向下转型）

安全的向下转型多做了一步操作：[[秘法笔记#基类与派生类的类型转换|代码实例]]

## 派生类对象间的赋值控制

从前面的知识，我们知道，基类的**拷贝构造函数**和**operator=运算符函数**不能被派生类继承，那么在执行派生类对象间的复制操作时，就需要注意以下几种情况:

1、如果派生类没有显示定义拷贝构造函数或者赋值运算符函数，但是基类定义类拷贝构造函数与赋值运算符函数，那么用一个已经存在的派生类对象初始化一个刚刚创建的派生类对象，或者用一个已经存在的派生类对象给另外一个已经存在的派生类对象进行赋值，那么两个派生类部分执行**缺省的行为**，而两个基类部分执行基类的拷贝构造函数或者赋值运算符函数。

2、如果派生类**显示定义拷贝构造函数或者赋值运算符函数**，基类也定义类拷贝构造函数与赋值运算符函数，那么用一个已经存在的派生类对象初始化一个刚刚创建的派生类对象，或者用一个已经存在的派生类对象给另外一个已经存在的派生类对象进行赋值，那么两个派生类部分执行派生类的拷贝构造函数或者派生类的赋值运算符函数，而两个基类部分就**不会再自动**执行基类的拷贝构造函数或者赋值运算符函数，除非在派生类的拷贝构造函数或者赋值运算符函数中**显示执行**基类的拷贝构造函数或者赋值运算符函数。


![image-20250120214925852](/1_store/1_asset/image-20250120214925852.png)


## 禁止复制

将基类的拷贝构造函数与赋值运算函数置为私有，派生类继承基类。这样派生类对象在拷贝或者赋值的情况下，就不能将基类部分进行拷贝或赋值了。

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052124949.png" alt="image-20230406213635739" style="zoom:67%;" />

<img src="C:/Users/kicei/AppData/Roaming/Typora/typora-user-images/image-20230406213703722.png" alt="image-20230406213703722" style="zoom:67%;" />

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052124283.png" alt="image-20230406213739970" style="zoom:67%;" />





# 多态

我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）。它们的目的都是为了代码重用。而多态除了代码的复用性外，还可以解决项目中紧偶合的问题，提高程序的可扩展性。

C++支持两种多态性：编译时多态和运行时多态。

**编译时多态**：也称为静态多态，我们之前学习过的**函数重载**、**运算符重载**就是采用的静态多态，C++编译器根据传递给函数的参数和函数名决定具体要使用哪一个函数，又称为先期联编（early binding）。

**运行时多态**：在一些场合下，编译器无法在编译过程中完成联编，必须在程序运行时完成选择，因此编译器必须提供这么一套称为“动态联编”（dynamic binding）的机制，也叫晚期联编（late binding）。

C++通过虚函数来实现动态联编。接下来，我们提到的多态，不做特殊说明，指的就是动态多态。



## 静态联编与动态联编

多态是面向对象程序设计语言中数据抽象和继承之外的第三个基本特征。 

1. 多态性(Polymorphism)**提供接口与具体实现之间的另一层隔离**，从而将”what”和”how”分离开来。多态性改善了代码的可读性和组织性，同时也使创建的程序具有可扩展性，项目不仅在最初创建时期可以扩展，而且当项目在需要有新的功能时也能扩展。
2.  C++ 支持**编译时多态(静态多态)**和**运行时多态(动态多态)**，**运算符重载和函数重载就是编译时多态，而派生类和虚函数实现运行时多态**。
3.  静态多态和动态多态的区别就是**函数地址是早绑定(静态联编)还是晚绑定(动态联编)**。

---

程序调用函数时，将使用哪个可执行代码块呢**？编译器负责这个问题**。 

在C语言中，这非常简单，因为每个函数名都对应一个不同的函数。在 C++ 中，由于函数重载的缘故，这项任务更复杂。编译器必须查看函数参数以及函数名才能确定使用哪个函数。 

将**源代码中的函数调用解释为执行特定的函数代码块**被称为**函数名联编**（binding）。 

如果函数的调用，在编译阶段就可以确定函数的调用地址，并产生代码，就是静态联编（static binding）, 就是说地址是早绑定的，又称为早期联编 (early binding)

而如果函数的调用地址不能在编译期间确定，而需要在运行时才能决定，就是动态联编（dynamic binding）, 就是说地址是晚绑定，又称为晚期联编（late binding）



### 静态联编

```c++
class Animal { //动物类
public:
	void speak() {
		cout << "动物在说话" << endl;
	}
};

class Cat:public Animal {  //猫类
public:
	void speak() {
		cout << "猫在说话" << endl;
	}
};

class Dog :public Animal{ //狗类
public:
	void speak() {
		cout << "狗在说话" << endl;
	}
};
//全局函数使用定义
// C++中父类的指针或者引用 可以指向子类的对象，不会报错
void doSpeak(Animal &animal) { //就相当于 Animal & animal = c; 创立c的一个引用别名是animal
    
	//调用了Animal中的speak()函数，属于地址早绑定，静态联编; 因为在编译期间就知道了speak函数的地址，是动物的speak();
    animal.speak();   
}
int main() {
	Cat c;
	doSpeak(c);

	Dog d;
	doSpeak(d);

	return 0;
}
```

虽然父类的指针或者引用可以指向子类的对象，但实际结果并没有我们想象的那样，猫在说话，狗在说话。而是都是输出狗在说话，**原因是在传参前，我不知道传的是猫的对象还是狗的对象，但接收对象前唯一能确定的是动物的speak函数地址**，所以打印结果如图。

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052124945.png" alt="image-20230405154916906" style="zoom: 80%;" />

### 动态联编

基类的speak函数使用 virtual修饰，表示是个虚函数

```c++
class Animal { //动物类
public:
	virtual void speak() {	//函数前用virtual修饰，表示是一个虚函数
		cout << "动物在说话" << endl;
	}
};

class Cat:public Animal {  //猫类
public:
	void speak() {
		cout << "猫在说话" << endl;
	}
};

class Dog :public Animal{ //狗类
public:
	void speak() {
		cout << "狗在说话" << endl;
	}
};

void doSpeak(Animal &animal) { 
    animal.speak();   
}
int main() {
	Cat c;	//派生类定义对象
	doSpeak(c);

	Dog d;
	doSpeak(d);

	return 0;
}
```

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052124485.png" alt="image-20230405155218820" style="zoom:80%;" />

## 虚函数

在**成员函数**的前面加上**virtual**关键字的函数，称为虚函数。

### 重定义（重写）要求

- 基类与派生类中函数名字要相同
- 函数的参数列表也要相同（包括参数的个数、参数的类型、参数的顺序）
- 函数的返回类型也要一致

总结：基类与派生类中的同名虚函数，除了**函数体可以不一样之外**，其他的全部都要保持一致。（函数的名字、函数的返回类型、函数的参数列表（参数个数、参数顺序、参数类型））

注意：基类中被声明为虚函数的成员函数，在派生类中加不加virtual都是虚函数。

多态的出现是在 基类指针（引用）、派生类对象中

```c++
void func(Base *p){
	p->print();
}
Base base(1111);
Derived derived(2222,3333);
func(&base);	//正常打印，不会体现多态,1111,基类指针基类对象
func(&derived);	//正常打印，不会体现多态,2222，基类指针派生类对象
//基类print函数前声明virtual是虚函数，则
func(&derived); //打印的是3333，基类指针派生类对象

```

注意：当是基类指针，派生类对象时，如果调用的函数基类派生类重名都有，那如果该函数不是虚函数，则调用的基类的函数；那如果该函数是虚函数，则调用的是派生类的函数。

### 虚函数的原理

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052124496.png" alt="image-20230405155536433" style="zoom: 50%;" />

当基类定义了虚函数的时候，就会在基类对象的存储布局的前面多一个虚函数指针，该虚函数指针会指向虚函数表，虚函数表简称为虚表。虚表中存放的是虚函数的入口地址。

当派生类继承基类的时候，会吸收基类的虚函数，那么在派生类的对象的存储布局的前面，多一个虚函数指针，该虚函数指针指向派生类自己的虚函数表，也就是虚表。该虚表里面存放的是从基类吸收的虚函数的入口地址，当派生类对该虚函数讲行重写，重定义之后，就会用派生类自己的虚函数的入口地址进行覆盖，存放的就是派生类自己的虚函数的入口地址。

### 动态多态被激活的五个条件

1、基类要定义虚函数
2、派生类要重写（重定义、覆盖）该虚函数
3、创建派生类的对象
4、基类的指针指向（引用绑定）派生类的对象
5、基类的指针（引用）调用虚函数



### 哪些函数不能被设置为虚函数

1、普通函数：因为虚函数必须是成员函数，而普通函数是非成员函数，所以就不能被设置为虚函数。

2、静态成员函数：静态成员函数发生的时机在编译的时候，而虚函数要体现多态，必须在运行的时候；静态成员函数没有this指针，是被该类的所有对象共享的，就是唯一的。

3、内联函数：内联成员函数发生的时机在编译的时候，而虚函数要体现多态，必须在运行的时候；内联如果写成虚函数，那么就是去了内联的函数。

4、友元函数：如果友元函数本身是一个普通函数，那么友元函数不能被设置为虚函数；但是如果友元函数本身是成员函数，那么该友元函数是可以被设置为虚函数的。

5、构造函数：构造函数发生的时机在编译的时候，而虚函数要体现多态，必须在运行的时候；构造函数是不可以被继承的，而虚函数是可以被继承的；如果将构造函数设置为虚函数，那么就需要通过虚表找到虚函数的入口地址，那么就需要虚函数指针指向虚表，而虚函数指针存在对象布局的最前面，而如果构造函数不调用，那么对象就不一定是完整的，那么对象的存储布局的前面就不一定有虚函数指针，那如果没有虚函数指针就不能指向虚表。



## 虚函数的访问

#### 1、使用指针进行访问

可以体现动态多态。

#### 2、使用引用进行访问

可以体现动态多态。

#### 3、使用对象进行访问

虚函数体现的就是普通成员函数的特性，在编译的时候就已经确定了函数调用。

#### 4、使用其他普通成员函数调用

#### 5、使用特殊成员函数进行访问

在调用Father的构造函数的时候，调用func1()时候，派生类Son的对象还没有构建完成，所以就看不到虚表这套逻辑，所以只能看到的func1()就是Father自己的。而当派生了Son销毁的时候，虚表都己经销毁了，所以再调用Father的func2()的时候，已经看不到Son的这套逻辑，所以就只会调用到Father自己的func2函数。所以都没有体现动态多态。

```c++
class A{
public:
	virtual	void func(int val = 1){
		cout << "A->" << val << endl;
	}
	virtual void test(){
		func();
	}
private:
	long _a;
};

class B: public A{
public:
	virtual	void func(int val = 10){
		cout << "B->" << val << endl;
	}
private:
	long _b;
};
int main(void){
	B b;
	A *p1 = (A*)&b;
	B *p2 = &b;
	p1->func();//指针类型是什么，就走哪一个类型里的函数。但除了函数体，参数等都是在编译阶段，确定了的
	p2->func();
	return 0;
}
// B->1
// B->10
```

所以，虽然p1走的是A中的func，使用的参数为1,但函数体的执行却是B中的。



## 抽象类

Q:动态多态与虚函数是不是等价的？

A:动态多态的体现需要虚函数；但是有虚函数并不一定能体现动态多态。

### 纯虚函数

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052125855.png" alt="image-20230405211340530" style="zoom:67%;" />

如果一个类中声明了纯虚函数，那么该类是不能创建对象，该类称为抽象类

如果抽象类的派生类没有实现所有的纯虚函数，那么抽象类的派生类也是抽象类，该派生类也是不能创建对象的。

不能给抽象类创建对象，也不能给不完整类型创建对象，但是可以给抽象类创建指针，也可以给不完整类创建指针。因为只要系统一定，那么指针的大小就确定了

可以在对纯虚函数进行重写的时候，加一个override用于对重写的检测。对纯虚函数进行重写时，派生类的重写函数前面记得加virtual



### 抽象类的第二种形式（了解）

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052125469.png" alt="image-20230405211729759" style="zoom:67%;" />



## 虚析构函数

当我们用基类指针申请Derived堆空间后，delete指针，却发现只执行了基类的析构函数，而派生类的析构函数没有执行。

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052125137.png" alt="image-20231205212532140" style="zoom:80%;" />

解决办法：`delete dynamic cast<Derived *>(pb);`    ，但是不够优雅

为了解决内存泄漏的问题，所以需要将析构函数设置为虚函数。

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052125937.png" alt="image-20230405212252991" style="zoom:67%;" />

总结：以后可以将所有的只要有多态产生的情况，都可以将基类的析构函数设置为虚函数，这样可以保证所有的派生类中的析构函数自动被设置为虚函数，可以避免内存泄漏的产生。



## 重载、重定义、隐藏

**重载**：在**同一个作用域**中，函数名字相同，函数的参数列表不一样（参数的个数、参数的类型、参数的顺序），注意：没有考虑返回类型。

**重定义（重写、覆盖）**：发生在基类与派生类中，同名的**虚函数**，并且参数列表也要一样，返回类型也要一样。

**隐藏**：发生在基类与派生类中，派生类中的函数与基类中的**函数名字相同**。派生类的数据成员也可以隐藏基类中的同名数据成员。（总结：可能发生的是数据成员，也可能是成员函数）



## 虚表的存在

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052125588.png" alt="image-20230407213658697" style="zoom:67%;" />

```c++
对象derived的地址: 0x7ffc1a2a2ba0
对象derived的地址: 0x7ffc1a2a2ba0
虚表的地址: 0x55949e9e4d00
虚表的地址: 0x55949e9e4d00
第一个虚函数的地址:  0x55949e7e40dc
第一个虚函数的地址 : 0x55949e7e40dc
第一个虚函数的地址:  0x55949e7e40dc
void Derived::func()

第二个虚函数的地址 : 0x55949e7e4114
void Derived::gunc()

第三个虚函数的地址 : 0x55949e7e414c
void Derived::hunc()



Base(long = 0)
Derived(long = 0, long  = 0)
对象derived2的地址: 0x7ffc1a2a2bc0
对象derived2的地址: 0x7ffc1a2a2bc0
虚表的地址: 0x55949e9e4d00
第一个虚函数的地址: 0x55949e7e40dc
~Derived()
~Base()
~Derived()
~Base()
```

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052125557.png" alt="image-20230407213803864" style="zoom:67%;" />

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052126024.png" alt="image-20230407213826689" style="zoom:67%;" />

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052126200.png" alt="image-20230407213838811" style="zoom:67%;" />



## 带虚函数多基派生

<img src="https://pnglist.obs.cn-east-3.myhuaweicloud.com/typora/202312052126728.png" alt="image-20230407215843832" style="zoom:67%;" />

如何判断一个函数是虚函数还是非虚函数？

就利用动态多态被激活的五个条件，在基类中实现这个函数，在派生类也实现这个函数，然后创建派生类对象，在构建基类的指针指向派生类对象，再使用基类的指针调用该函数，如果调用的结果显示是基类中的函数体，那么该函数就是非虚函数，否则就是虚函数。

```c++
//判断class C中的c()是否为虚函数
C *pc;
D d; 
pc = &d;
pc -> c();//如果打印的是c::c()则不是虚函数，如果打印的是d::c()代表多态，c()是虚函数
```



# 多态内存布局



# 虚拟继承

https://blog.csdn.net/weixin_44212838/article/details/125971934

