## 固定宽度整数和 size_t

前面讲过 C++ 只能保证整数变量的最小大小，但根据目标系统的不同，它们可能会更大。

**问题 1：为什么不固定整数变量的大小？**

答：历史原因，早期计算机运行速度很慢，因此性能是最重要的。C 语言故意不确定整数的大小，这样编译器实现者就可以为 `int` 选择一个在目标计算机体系结构上性能最佳的大小。

int 类型的最小大小是 2 字节，但在现代体系结构中通常是 4 字节。 如果假定 int 为 4 字节，那么在实际上 int 为 2 字节的系统中，程序很有可能出现错误，并且如果反过来则分配的内存有一半是浪费掉的。

解决方式：C99 定义了一组固定宽度的整数（在 `stdint.h` 头文件中），这些整数保证在任何体系结构上大小相同。作为 C++11 的一部分，C++ 正式采用了这些固定宽度的整数。 可以通过包含 `<cstdint>` 头文件来访问这些整数，它们被定义在 `std` 命名空间内。

![image-20241116141504652](./../../1_store/1_asset/image-20241116141504652.png)

固定宽度整数通常有两个缺点。 首先，固定宽度整数不能保证在所有架构上都能定义。 它们只存在于有与其宽度相匹配的基本类型并遵循特定二进制表示法的系统中。 在不支持固定宽度整数的体系结构上，你的程序将无法编译。 不过，鉴于大多数现代体系结构已将 8/16/32/64 位变量标准化，除非你的程序需要移植到某些特殊的大型机或嵌入式体系结构上，否则这不太可能成为一个问题。

其次，如果使用固定宽度的整数，在某些体系结构上可能会比更宽类型的效率更慢。 例如，如果你需要一个保证为 32 位的整数，你可能会决定使用 `std::int32_t`，但实际上你的 CPU 在处理 64 位整数时可能会更快。 不过，CPU 处理给定类型的速度更快，并不意味着程序的整体速度会更快--现代程序通常受内存使用量而非 CPU 的限制，内存占用越大，程序的运行速度就越慢，而 CPU 处理速度越快，程序的运行速度就越快。 如果不进行实际测量，很难知道这一点。

---

## 快速整数和最小整数

为了解决上述固定宽度整数的弊端，C++ 还定义了两组可供选择的整数类型。 

- 快速类型（`std::int_fast#_t` 和 `std::uint_fast#_t`）提供了宽度至少为 `#` 位（其中 # = 8、16、32 或 64）的最快有符号/无符号整数类型。 例如，`std::int_fast32_t` 将提供至少 32 位的最快有符号整数类型。 所谓最快，是指 CPU 处理速度最快的整数类型。 
- 最小类型（`std::int_least#_t` 和 `std::uint_least#_t`）提供宽度至少为 `#` 位（其中 # = 8、16、32 或 64）的最小有符号/无符号整数类型。 例如，`std::uint_least32_t` 将提供宽度至少为 32 位的最小无符号整数类型。

示例如下：

```c++
#include <cstdint> // for fast and least types
#include <iostream>

int main()
{
	std::cout << "least 8:  " << sizeof(std::int_least8_t) * 8 << " bits\n";
	std::cout << "least 16: " << sizeof(std::int_least16_t) * 8 << " bits\n";
	std::cout << "least 32: " << sizeof(std::int_least32_t) * 8 << " bits\n";
	std::cout << '\n';
	std::cout << "fast 8:  " << sizeof(std::int_fast8_t) * 8 << " bits\n";
	std::cout << "fast 16: " << sizeof(std::int_fast16_t) * 8 << " bits\n";
	std::cout << "fast 32: " << sizeof(std::int_fast32_t) * 8 << " bits\n";

	return 0;
}
```

你可以看到，`std::int_least16_t` 是 16 位，而 `std::int_fast16_t` 实际上是 64 位。 这是因为在测试机器上，64 位整数的处理速度比 16 位整数快。

然而，这些快速、最少的整数也有其自身的缺点： 首先，实际使用它们的程序员并不多，不熟悉它们可能会导致错误。 其次，快速类型可能会导致内存浪费，因为它们的实际大小可能比其名称所表示的要大。 更严重的是，由于快速/最小整数的大小可能不同，在它们解析为不同大小的架构上，程序可能会表现出不同的行为。 例如：

```c++
#include <cstdint>
#include <iostream>

int main()
{
    std::uint_fast16_t sometype { 0 };
    sometype = sometype - 1; // intentionally overflow to invoke wraparound behavior

    std::cout << sometype << '\n';

    return 0;
}
```

根据 `std::uint_fast16_t` 是 16 位、32 位还是 64 位，这段代码会产生不同的结果。 在对程序进行严格测试之前，很难知道程序在哪些地方可能无法按照预期运行。

---

`std::int8_t` 和 `std::uint8_t` 可能表现得像字符而不是整数

由于 C++ 规范中的一个疏忽，大多数编译器将 `std::int8_t` 和 `std::uint8_t`（以及相应的快速和最小定宽类型）分别定义为有符号 `char` 和无符号 `char` 类型，并对它们进行相同的处理。 这意味着这些 8 位类型的行为可能（也可能不）与其他固定宽度类型不同，从而可能导致错误。 这种行为与系统有关，因此在一种体系结构上表现正确的程序，在另一种体系结构上可能无法编译或表现不正确。

在存储整数值时，如果特定大小很重要，通常最好避免使用 `std::int8_t` 和 `std::uint8_t`（以及相关的 fast 和 least 类型），而应使用 `std::int16_t` 或 `std::uint16_t`。

---

对于整数类型的最佳做法：

- 当整数的大小不重要，且变量的寿命较短时，首选 int。
- 在存储需要保证范围的数量时，优先使用 `std::int#_t`。
- 在进行位操作或需要定义明确的环绕行为时，首选 `std::uint#_t`。

---



**std:: size_t** 的大小为 4 字节。我们可以推断操作符 `sizeof` 返回一个整数值，但返回值是什么整数类型呢？ int？ 还是 short？ 答案是 `sizeof` 返回一个 std:: size_t 类型的值。std:: size_t 是实现定义的无符号整型的别名。 换句话说，编译器会决定 std:: size_t 是无符号 int、无符号 long 还是无符号 long long，等等。它在标准库中用于表示对象的字节大小或长度。

std:: size_t 定义在许多不同的头文件中。 如果需要使用 `std::size_t`，`<cstddef>` 是最好的头文件，因为它包含的其他定义标识符最少。

## 浮点型

请注意，默认情况下，浮点字面量默认为 double 类型。 后缀 f 用于表示 float 类型的字面量。

## 布尔型

如果想让 `std::cout` 打印 true 或 false，而不是 0 或 1，可以输出 `std::boolalpha`。 这不会输出任何内容，但会操纵 `std::cout` 输出 bool 值的方式(例如打印 true 或 false)。

## 类型转换

在大多数情况下，C++ 允许我们将一种基本类型的值转换为另一种基本类型。 将一个值从一种类型转换为另一种类型的过程称为 **类型转换**。

默认情况下，小数部分为 0 的浮点数值打印时不带小数位（如 5.0 打印为 5）。

当编译器在我们没有明确要求的情况下代表我们进行类型转换时，我们称之为隐式类型转换。

### 类型转换产生新值

尽管称为转换，但类型转换实际上并不改变被转换值的值或类型。 相反，要转换的值被用作输入，转换的结果是目标类型的新值。类型转换使用直接初始化，从不同类型的值生成目标类型的新值。

列表初始化将确保我们不会尝试用初始化器初始化变量，而初始化器在隐式类型转换时会丢失值, 例如：

```c++
int main()
{
    double d { 5 }; // okay: int to double is safe
    int x { 5.5 }; // error: double to int not safe

    return 0;
}
```

通过 static_cast 操作符进行显式类型转换的介绍：

要执行显式类型转换，大多数情况下我们会使用 static_cast 操作符：

```c++
static_cast<new_type>(expression)
```

值得注意的是，static_cast 的参数是一个表达式。 当我们传入一个变量时，会对该变量进行求值，然后将其转换为新类型。 将变量值转换为新类型不会影响变量本身。

符号整型可以通过 static_cast 转换为无符号整型，但反之不成立。
