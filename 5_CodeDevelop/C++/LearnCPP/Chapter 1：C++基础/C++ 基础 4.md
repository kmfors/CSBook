# C++ 函数与文件 2

## 预处理器

当您编译项目时，您可能会希望编译器完全按照您编写的代码编译每个代码文件，但实际上并非如此。事实上并非如此，在编译之前，每个代码文件（`.cpp`）都要经过一个预处理阶段。在这一阶段，一个名为预处理器的程序会对代码文件的文本进行各种修改。预处理器实际上不会以任何方式修改原始代码文件，相反，预处理器所做的所有修改都是在内存中或使用临时文件临时进行的。

从历史上看，预处理器是一个独立于编译器的程序，但在现代编译器中，预处理器可能直接内置于编译器本身。

预处理器的大部分工作都相当无趣。例如，它删除注释，确保每个代码文件以换行结束。不过，预处理器还有一个非常重要的作用：它负责处理 `#include` 指令。

预处理器处理完代码文件后，其结果称为翻译单元。编译器随后对该翻译单元进行编译。

The entire process of preprocessing, compiling, and linking is called translation.

### 预处理器指令

预处理器运行时，会扫描代码文件（从上到下），寻找预处理器指令。预处理器指令（通常只称为指令）是以 `#` 符号开头、以换行符（而不是分号）结尾的指令。这些指令告诉预处理器执行某些文本操作任务。请注意，预处理器并不理解 C++ 语法，相反，这些指令有自己的语法。

当你 `#include` 一个文件时，预处理器会用被包含文件的内容替换 `#include` 指令。然后对包含的内容进行预处理（这可能会导致其他 `#includes` 文件被递归预处理），然后再对文件的其他部分进行预处理。

预处理器处理完代码文件和所有 `#included` 内容后，得到的结果称为翻译单元。翻译单元就是发送给编译器进行编译的内容。一个翻译单元既包含代码文件中经过处理的代码，也包含所有 `#` 包含文件中经过处理的代码。

### 宏定义

`#define` 指令可用于创建宏。在 C++ 中，宏是定义如何将输入文本转换为替换输出文本的规则。

宏有两种基本类型：宏对象和宏函数。（object-like macros, and function-like macros.）

宏函数的作用与函数类似，目的也类似。它们的使用通常被认为是不安全的，而且它们能做的任何事情几乎都能由普通函数完成。

宏对象有两种定义方式：

```c++
#define IDENTIFIER
#define IDENTIFIER substitution_text
```

上面的定义没有替换文本，而下面的定义有。由于这些都是预处理器指令（而不是语句），请注意这两种形式都不以分号结束。宏的标识符使用与普通标识符相同的命名规则：可以使用字母、数字和下划线，不能以数字开头，也不能以下划线开头。按照惯例，宏名通常都是大写字母，用下划线分隔。

### 带替换文本的宏对象

当预处理器遇到该指令时，标识符的任何进一步出现都会被 substitution_text 所替换。标识符通常使用大写字母，下划线代表空格。

在 C 语言中，带有替换文本的宏对象被用来为字面量赋名。由于 C++ 中有更好的方法，因此不再需要这种方法。带有替换文本的类对象宏现在通常只出现在传统代码中，我们建议避免使用（替换文本为字面量赋名）。

### 无替换文本的宏对象

这种形式的宏的工作原理就像你想象的那样：任何标识符的再次出现都会被移除，取而代之的是空无一物！与带有替换文本的类对象宏不同，这种形式的宏通常被认为是可以使用的。

## 条件编译

条件编译预处理器指令允许你指定在什么条件下可以编译或不可以编译。有许多不同的条件编译指令，但我们在这里只介绍使用最多的三种： `#ifdef` 、 `#ifndef` 和 `#endif` 。

`#ifdef` 预处理器指令允许预处理器检查标识符是否已被 `#defined` 。如果是，则编译 `#ifdef` 和匹配的 `#endif` 之间的代码。否则，代码将被忽略。

### `#if 0`

条件编译还有一个更常见的用法，就是使用 `#if 0` 来排除编译代码块（就像在注释块中一样）：

这为 "注释掉" 包含多行注释的代码提供了一种方便的方法（由于多行注释不可嵌套，因此无法使用其他多行注释来注释掉这些代码）。要暂时重新启用被 `#if 0` 封装的代码，可以将 `#if 0` 改为 `#if 1`。


### 类对象宏不会影响其他预处理器指令

```c++
#define PRINT_JOE

#ifdef PRINT_JOE
// ...
```

既然我们将 PRINT_JOE 定义为 "无"，为什么预处理器没有将 `#ifdef PRINT_JOE` 中的 PRINT_JOE 替换为 "无 " 呢？

宏只能对非预处理命令进行文本替换。由于 `#ifdef PRINT_JOE` 是一条预处理器命令，因此文本替换不适用于该命令中的 PRINT_JOE。

```c++
#define FOO 9 // Here's a macro substitution

#ifdef FOO // This FOO does not get replaced because it’s part of another preprocessor directive
    std::cout << FOO << '\n'; // This FOO gets replaced with 9 because it's part of the normal code
#endif
```

然而，预处理器的最终输出根本不包含任何指令--它们都在编译前被解析/删除了，因为编译器不知道该如何处理它们。

### `#define` 作用域

指令会在编译前逐个文件从上到下进行解析。

预处理器完成后，该文件中所有已定义的标识符都将被丢弃。这意味着，指令的有效期仅从定义时起至其所在文件的末尾。在一个文件中定义的指令对其他文件没有任何影响（除非它们被 `#included` 到另一个文件中）。例如



## 头文件

C++ 代码文件（扩展名为 `.cpp`）并不是 C++ 程序中常见的唯一文件。另一种文件称为头文件。头文件的扩展名通常是 .h，但偶尔也会出现扩展名为 .hpp 或完全没有扩展名的头文件。头文件的主要作用是将声明传播到代码（.cpp）文件中。

头文件允许我们将声明放在一个位置，然后在需要的地方导入。在多文件程序中，这可以节省大量的键入工作。

## 使用标准库头文件

当你 `#include` 一个文件时，被包含文件的内容就会插入到包含点。这为从另一个文件中引入声明提供了一种有用的方法。


## 使用头文件传播前向声明

! [[20240729142933.png]]

## 在头文件中包含定义如何导致违反单定义规则？

目前，应避免将函数或变量定义放在头文件中。如果头文件被包含在多个源文件中，这样做通常会违反单定义规则（ODR）。

请勿将函数和变量定义放在头文件中（暂时如此）。如果在头文件中定义这两种定义，那么如果该头文件被 `#include` 到多个源代码 (.cpp) 文件中，很可能会导致违反单定义规则 (ODR)。

当我们使用双引号时，我们在告诉预处理器这是我们编写的头文件。预处理器首先会在当前目录中搜索头文件。如果在当前目录下找不到匹配的头文件，就会搜索包含目录。

使用 g++ 时，可以使用 -I 选项指定另一个包含目录： `g++ -o main -I/source/includes main.cpp`  注意，-I 后面没有空格。

> [!NOTE]
>
> 每个文件都应明确 #include 编译所需的所有头文件。 不要依赖从其他头文件中临时包含的头文件。

为了让编译器最大限度地标记出缺失的包含，请按如下顺序排列 `#includes` ：

- 配对头文件
- 项目中的其他头文件
- 三方库头文件
- 标准库头文件

每个分组的标题应按字母顺序排序（除非第三方库的文档另有说明）。


## 头文件守卫

我们注意到一个变量或函数标识符只能有一个定义（一个定义规则）。因此，如果程序对变量标识符进行了多次定义，就会导致编译错误。

虽然这些程序很容易修复（删除重复定义），但在头文件中，很容易出现头文件中的定义被包含多次的情况。当一个头文件 `#include` 另一个头文件（这很常见）时，就会出现这种情况。

我们可以通过一种称为 "头文件守卫"（也称为 "包含防护"）的机制来避免上述的重复定义问题。头文件防护是一种有条件的编译指令，其形式如下：

```c++
#ifndef SOME_UNIQUE_NAME_HERE
#define SOME_UNIQUE_NAME_HERE

// your declarations (and certain types of definitions) here

#endif
```

当 `#include` 此头文件时，预处理器将检查 SOME_UNIQUE_NAME_HERE 是否已在此翻译单元中定义。如果这是第一次包含该头文件，那么 SOME_UNIQUE_NAME_HERE 将不会被定义。因此，它会 `#defines SOME_UNIQUE_NAME_HERE` 并包含文件内容。如果在同一文件中再次包含该文件头，SOME_UNIQUE_NAME_HERE 将已在第一次包含文件头内容时定义，而文件头的内容将被忽略（这要归功于 `#ifndef` ）。

所有头文件都应该有头文件保护。 SOME_UNIQUE_NAME_HERE 可以是你想要的任何名称，但按照惯例，它被设置为头文件的完整文件名，大写，用下划线代替空格或标点符号。

头文件保护并不能防止一个头文件被包含到不同的代码文件中。需要注意的是，头文件保护的目的是防止代码文件收到多份头文件保护。从设计上讲，头文件保护机制并不能防止某个头文件被包含（一次）到不同的代码文件中。这也会造成意想不到的问题。考虑一下

! [[20240729152206.png]]

请注意，main.cpp 和 square.cpp 中都包含了 square.h。这意味着，square.h 的内容将被包含到 square.cpp 和 main.cpp 中各一次。

让我们详细分析一下出现这种情况的原因。从 square.cpp 中包含 square.h 时，SQUARE_H 会被定义直到 square.cpp 的末尾。该定义可防止 square.h 被第二次包含到 square.cpp 中（这正是头保护的意义所在）。不过，一旦 square.cpp 运行完毕，SQUARE_H 就不再被视为已定义。这意味着当预处理程序在 main.cpp 上运行时，main.cpp 中并没有初始定义 SQUARE_H。

解决这个问题的最佳方法是将函数定义放在 .cpp 文件中，这样头文件中就只包含一个正向声明：

! [[20240729152536.png]]

现在编译程序时，函数 getSquareSides 只有一个定义（通过 square.cpp），因此链接器很高兴。文件 main.cpp 可以调用这个函数（尽管它存在于 square.cpp），因为它包含了 square.h，而 square.h 中有一个函数的前向声明（链接器会将 main.cpp 中对 getSquareSides 的调用与 square.cpp 中对 getSquareSides 的定义连接起来）。

`#pragma once` 

现代编译器使用 `#pragma` 预处理器指令支持更简单的头保护替代形式：

```c++
#pragma once

// your code here
```

`#pragma once` 与头文件保护的目的相同：避免头文件被多次包含。对于传统的头文件保护，开发人员负责保护头文件（通过使用预处理器指令 `#ifndef` 、 `#define` 和 `#endif` ）。使用 `#pragma once`，我们要求编译器对头信息进行保护。至于如何做到这一点，则是具体实现中的细节问题。

有一种已知的情况， `#pragma once` 通常会失败。如果一个头文件被复制到文件系统的多个地方，如果头文件的两个副本都被包含在内，头文件防护将成功地对相同的头文件进行去重，但 `#pragma once` 不会（因为编译器不会意识到它们实际上是相同的内容）。

对于大多数项目来说， `#pragma once` 可以很好地发挥作用，而且现在许多开发人员更喜欢它，因为它更简单，更不容易出错。许多集成开发环境也会在通过集成开发环境生成的新头文件顶部自动包含 `#pragma once`。

由于 `#pragma once` 并未在 C++ 标准中定义，因此某些编译器可能无法实现它。因此，一些开发公司（如 Google）建议使用传统的头保护。在本系列教程中，我们将倾向于使用头保护，因为这是最传统的头保护方式。不过，目前对 `#pragma once` 的支持已相当普遍，如果您想使用 `#pragma once` 代替，这在现代 C++ 中已被普遍接受。

头文件保护旨在 **确保特定头文件的内容不会被多次复制到任何一个文件中**，以防止重复定义。重复声明没有问题 -- 但即使你的头文件只包含声明（没有定义），包含头文件保护仍是一种最佳做法。请注意，头文件保护并不能防止头文件的内容被复制（一次）到不同的项目文件中。这是一件好事，因为我们经常需要在不同的项目文件中引用某个头文件的内容。







