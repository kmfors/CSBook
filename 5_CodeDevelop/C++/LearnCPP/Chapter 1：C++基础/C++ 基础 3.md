
# C++ 基础 3

函数是一个可重复使用的语句序列，旨在完成一项特定的工作。函数为我们提供了一种将程序分割成小块、模块化代码的方法，这些代码更易于组织、测试和使用。

当遇到函数调用时，程序将在一个函数内按顺序执行语句。 函数调用是一个表达式，它告诉 CPU 中断当前函数并执行另一个函数。 CPU 在当前执行点 "放置书签"，然后调用（执行）函数调用中指定的函数。 当调用的函数结束时，CPU 会返回到书签所在的位置，并重新开始执行。

发起函数调用的函数是调用者，被调用的函数是被调用者或被调用函数。

## 函数简介

下面是一个示例程序，展示了如何定义和调用新函数：

```c++
#include <iostream> // for std:: cout

// Definition of user-defined function doPrint()
void doPrint() // doPrint() is the called function in this example
{
    std::cout << "In doPrint()\n";
}

// Definition of function main()
int main()
{
    std::cout << "Starting main()\n";
    doPrint(); // Interrupt main() by making a function call to doPrint().  main() is the caller.
    std::cout << "Ending main()\n"; // this statement is executed after doPrint() ends

    return 0;
}
```

函数的一个好处是可以被多次调用。与其他编程语言不同，在 C++ 中，不能在其他函数内部定义函数。

## 返回值函数

返回值的函数称为返回值函数。

### 返回值

在编写用户自定义函数时，我们可以决定是否将函数值返回给调用者。向调用者返回一个返回值，需要两样条件：

1. 函数必须指明返回值的类型
2. 函数内部用 `return` 显式返回一个值（任意处置）。


### 代码状态

`main()` 的返回值被称为状态代码（或退出代码），状态代码也会传回程序的调用者。程序调用者可以通过状态代码来判断程序是否运行成功。根据定义，状态代码为 0 表示程序执行成功。非零状态代码通常用来表示失败。

C++ 标准只定义了 3 个状态代码的含义：

- `0`：程序执行成功
- `EXIT_SUCCESS`：程序执行成功
- `EXIT_FAILURE`：程序执行失败

`EXIT_SUCCESS` 和 `EXIT_FAILURE` 是 `<cstdlib>` 头中定义的预处理器宏：

```c++
#include <cstdlib> // for EXIT_SUCCESS and EXIT_FAILURE

int main()
{
    return EXIT_SUCCESS;
}
```

如果希望最大限度地提高可移植性，则只能使用 `0` 或 `EXIT_SUCCESS` 表示成功终止，或 `EXIT_FAILURE` 表示失败终止。

### 未定义行为

返回值函数不返回值将产生未定义的行为，如果函数的返回类型不是 void，那么该函数就是返回值函数。返回值函数必须返回该类型的值（使用返回语句），否则将导致未定义的行为。

- 如果 `main` 函数没有提供返回语句，则将隐式返回 0。
- 返回值函数向调用者返回一个值，但返回语句中提供的值并不需要是字面意义上的，它可以是任何有效表达式的结果，包括一个变量，或调用另一个返回值的函数。



## 无返回值函数

无返回值函数（void functions）不需要向调用者返回值，使用的是 `void` 返回类型。`void` 函数会在函数结束时自动返回给调用者。无需返回语句。

在 void 函数中可以使用 return 语句（不带返回值）--这样的语句将导致函数在执行 return 语句时返回给调用者。这与函数结束时发生的情况是一样的。因此，在 void 函数末尾添加空 return 语句是多余的：

与未使用的局部变量一样，编译器可能会警告说变量被定义但未被使用。在函数定义中，函数参数的名称是可选的。因此，如果函数参数需要存在，但在函数体中没有使用，可以直接省略名称。没有名称的参数称为未命名参数.

在函数定义中，函数参数的名称是可选的。因此，如果函数参数需要存在，但不在函数体中使用，可以直接省略参数名。没有名称的参数称为匿名参数：

```c++
void doSomething(int) // ok: unnamed parameter will not generate warning
{
}
```

当函数参数存在但未在函数体中使用时，请不要为其命名。您可以选择将名称放在注释中。


## 局部作用域

### 局部变量

在函数体内部定义的变量称为局部变量，函数参数通常也被视为局部变量，我们将把它们作为局部变量包含在内：

```c++
int add(int x, int y) // function parameters x and y are local variables
{
    int z{ x + y }; // z is a local variable

    return z;
}
```

### 局部变量的生命周期

函数参数在输入函数时创建并初始化，函数体中的变量在定义时创建并初始化。局部变量的销毁顺序与创建顺序相反，在定义该变量的大括号集合的末尾（或者对于函数参数来说，在函数的末尾）。

```c++
int add(int x, int y) // x and y created and initialized here
{
    int z{ x + y };   // z created and initialized here

    return z;
} // z, y, and x destroyed here
```

一个对象的生命周期也被定义为从创建到销毁的时间。请注意，变量的创建和销毁发生在程序运行时（称为运行时），而不是编译时。因此，生命周期是一个运行时属性。

对象在被销毁后会发生什么？在大多数情况下，什么也不会发生。被销毁的对象将变得无效，任何对该对象的进一步使用都将导致未定义的行为。在销毁后的某个时间点，对象所使用的内存将被释放，以便重新使用。

如果对象是类类型对象，在销毁之前，会调用一个称为析构函数的特殊函数。在许多情况下，析构函数什么也不做，在这种情况下不会产生任何代价。

### 局部作用域

标识符的作用域决定了标识符在源代码中的可见和使用位置。当标识符可以被看到和使用时，它在作用域内。当一个标识符无法被看到时，则无法使用它，我们称之为 "超出范围"。作用域是一个编译时属性，当标识符不在作用域中时，试图使用它将导致编译错误。

局部变量的作用域从定义变量时开始，到定义变量的大括号结束时终止（对于函数参数，则到函数结束时终止）。这样可以确保变量在定义点之前无法使用（即使编译器选择在定义点之前创建变量）。在一个函数中定义的局部变量在其他被调用的函数中也没有作用域。

在函数体中声明的函数参数或变量的名称只能在声明它们的函数中看到。这意味着一个函数中的局部变量在命名时可以不考虑其他函数中的变量名。这有助于保持函数的独立性。

在哪里定义局部变量？在现代 C++ 中，最佳做法是函数体内部的局部变量应尽可能在首次使用时定义

## 临时对象

临时对象（有时也称为匿名对象）是由编译器创建的未命名对象，用于临时存储某个值。创建临时值的方法有很多种。

临时对象根本没有作用域（这是有道理的，因为作用域是标识符的属性，而临时对象没有标识符）。临时对象在其创建的完整表达式结束时被销毁。

在使用临时对象初始化变量的情况下，初始化发生在销毁临时对象之前。

在现代 C++ 中（尤其是自 C++17 以来），编译器有很多技巧来避免在以前需要生成临时变量的地方生成临时变量。 例如，当我们使用返回值来初始化一个变量时，通常会创建一个临时来保存返回值，然后使用临时来初始化变量。 然而，在现代 C++ 中，编译器通常会跳过创建临时文件，直接使用返回值初始化变量。



## 前向声明与定义

看一个反例：

```c++
#include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is: " << add(3, 4) << '\n';
    return 0;
}

int add(int x, int y)
{
    return x + y;
}
```

编译报错：`add.cpp(5) : error C3861: 'add': identifier not found`

### 重排函数定义

解决上面问题的方法一是：重排函数定义的顺序。

将 `add` 定义在 `main` 之前：这样，当 `main` 调用 `add` 时，编译器清楚知道 add 是什么了。然而，在一个较大的程序中，要弄清楚哪些函数调用哪些其他函数（以及调用的顺序），以便按顺序声明这些函数，可能会相当繁琐。

### 使用前向声明

解决上面问题的方法二是：使用前向声明。

前向声明允许我们在实际定义标识符之前告诉编译器标识符的存在。值得注意的是，函数声明不需要指定参数的名称（因为它们不被视为函数声明的一部分）。

如果进行了前向声明，但函数从未被调用，程序将正常编译和运行。但如果进行了前向声明并调用了函数，但程序从未定义该函数，那么程序将正常编译，但链接器会抱怨无法解析函数调用（因为找不到实际定义的位置）。

### 声明与定义

声明告诉编译器标识符的存在及其相关类型信息。下面是一些声明示例：

```c++
int add(int x, int y); // 告诉编译器，add 函数有两个 int 参数，和一个 int 返回值，没有函数体!
int x;                 // 告诉编译器，一个名为 x 的 int 变量
```

定义是实际实现（对于函数和类型）或实例化（对于变量）标识符的声明。下面是一些定义示例：

```c++
// because this function has a body, it is an implementation of function add()
int add(int x, int y)
{
    int z{ x + y };   // instantiates variable z

    return z;
}

int x;                // instantiates variable x
```

在 C++ 中，所有定义都是声明。因此，int x; 既是定义也是声明。

相反，并非所有声明都是定义。不是定义的声明称为纯声明。纯声明的类型包括函数、变量和类型的正向声明。在普通语言中，"声明 " 通常指 "纯粹的声明"，而 "定义 " 则指 "同时作为声明的定义"。因此，我们通常称 `int x;` 为定义，尽管它既是定义又是声明。

当编译器遇到一个标识符时，它会进行检查，以确保该标识符的使用是有效的（例如，标识符在作用域内，它的使用方式在语法上是有效的，等等）。

在大多数情况下，一个声明足以让编译器确保标识符被正确使用。例如，当编译器遇到函数调用 `add(5, 6)` 时，如果它已经看到了 `add(int, int)` 的声明，那么它就可以确认 `add` 实际上是一个接受两个 `int` 参数的函数。编译器并不需要真正看到函数 `add` 的定义（该定义可能存在于其他文件中）。不过，在少数情况下，编译器必须能够看到完整的定义才能使用标识符（例如模板定义和类型定义）。

下面是一个汇总表：

![image-20241115111439727](./../../1_store/1_asset/image-20241115111439727.png)


### 单一定义规则（ODR）

一个定义规则（简称 ODR）是 C++ 中一条著名的规则。 ODR 包括三个部分：

1. 在一个文件中，给定作用域内的每个函数、变量、类型或模板只能有一个定义。在不同作用域中出现的定义（如在不同函数中定义的局部变量，或在不同命名空间中定义的函数）并不违反这一规则。
2. 在一个程序中，给定作用域中的每个函数或变量只能有一个定义。之所以有这条规则，是因为程序可以有多个文件。链接器看不到的函数和变量不包括在此规则中。
3. 允许在不同文件中重复定义类型、模板、内联函数和内联变量，只要每个定义都是相同的。

违反 ODR 第 1 部分会导致编译器发出重新定义错误。违反 ODR 第 2 部分会导致链接器发出重新定义错误。违反 ODR 第 3 部分将导致未定义的行为。



