C++语言定义了两个运算符来分配和释放动态内存。运算符 new 分配内存，delete 释放 new 分配的内存。

# 基本理解
## 分配动态内存 new

通过 new 为对象动态分配内存，并返回一个指向该对象的指针。

```c++
// 默认情况下，动态分配的对象时默认初始化的
int *pi = new int;
```

**内置类型或组合类型的对象的值是未定义，而类类型对象将使用默认构造函数进行初始化。**


**动态分配的 const 对象**：一个动态分配的 const 对象必须进行初始化。

```c++
// 用 new 分配 const 对象是合法的
const int *pci = new const int(1024);

const string *pci = new const string;
```

内存耗尽：

如果自由空间被耗尽，new 表达式就会失败。默认情况下，如果 new 不能分配所要求的内存空间，它会抛出一个类型为 bad_alloc 的异常。bad_alloc 和 nothrow 都定义在头文件 new 中。

```c++
// 如果分配失败，new 抛出 std::bad_alloc
int *p1 = new int;

// 如果分配失败，new 返回一个空指针
int *p2 = new (nothrow) int;
```


## 释放动态内存 delete

为防止内存耗尽，动态内存使用完毕后，必须将其归还给系统。通过 delete 表达式来将动态内存归还给系统。

```c++
delete p;
```

delete 表达式执行两个动作：销毁给定的指针指向的对象；释放对应的内存。

通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象，也不能分辨一个指针所指向的内存是否已经被释放了。因而 delete 释放一块并非 new 分配的内存，或将相同指针释放多次，其行为是未定义的，尽管它们可能会被编译通过，但一定是不正确的。

但对于 const 对象的值不能被改变，但它本身是可以被销毁的。

```c++
const int *pci = new const int(1024);
delete pci; // 正确释放
```


## 动态对象的生存期

动态对象的生存期直到被释放为止。对于一个内置指针管理的动态对象，直到显式释放之前它都是存在的。

与类类型不同，内置类型的对象被销毁时什么也不会发生。特别是，当一个指针离开其作用域时，它所指向的对象什么也不会发生。如果这个指向指向的时动态内存，那么内存将不会被自动释放。


## delete 之后的问题

当我们 delete 一个指针后，指针值就变为无效了。虽然指针已经无效，但在很多机器上指针仍然保存着（已经释放了的）动态内存的地址。即悬空指针，指向一块曾经保存数据对象但现在已经无效的内存的指针。

为避免悬空指针的问题：在指针即将离开其作用域之前释放它所关联的内存。如果我们需要保留指针，可以在 delete 之后将 nullptr 赋予指针（重置指针值），清晰表明该指针不指向任何对象。

但对于另一个问题就是，可能有多个指针指向相同的内存。当 delete 并重置该指针后，对其他任何指向（已经释放的）内存的指针是没有作用的。


# 发生步骤

使用 new 表达式时发生的三个步骤：

1. 调用名为 operator new 的标准库函数，分配足够大的原始未类型化的内存，以保存指定类型的一个对象。
2. 运行该类型的一个构造函数初始化对象。
3. 返回指向新分配并构造的构造函数对象的指针。

使用 delete 表达式时发生的两个步骤：

1. 调用析构函数，回收对象中数据成员所申请的资源。
2. 调用名为 operator delete 的标准库函数释放该对象所指向的内存。
