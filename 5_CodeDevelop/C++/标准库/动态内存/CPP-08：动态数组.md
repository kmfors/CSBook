我们通常称 new T[] 分配的内存并不是一个数组类型，而是得到一个数组元素类型的指针。

初始化动态分配对象的数组

默认情况下，new 分配的对象，不管是单个分配的还是数组中的，都是默认初始化的，可以对数组中的元素进行值初始化。

```c++
// 10个未初始化的 int
int *pia = new int[10];

// 10个值初始化为0的int
int *pia2 = new int[10]();

// 初始化器初始化
int *pia = new int[10]{1,2,3,4,5,6,7,8,9};
```

虽然我们用空括号对数组中元素进行值初始化，但不能在括号中给出初始化器，这意味着不能用 auto 分配数组。

动态分配一个空数组是合法的。

```c++
size_t n = get_size();
int *p = new int[n]; // 分配数组用于保存元素
// 注意即使n是0，分配数组依然正确，只是不能解引用而已
```

释放动态数组

```c++
delete p;     // p必须指向一个动态分配的对象或为空
delete [] pa; // p必须指向一个动态分配的数组或为空
```

![[20240719135326.png]]

标准库提供了一个管理 new 分配的数组的 unique_ptr 版本。为了用一个 unique_ptr 管理动态数组，我们必须在对象类型后面跟一对空方括号：

```c++
unique_ptr<int[]> up(new int[10]);
up.release(); // 自动用 delete[] 销毁其指针
```

当一个 unique_ptr 指向一个数组时，我梦不能使用点和箭头成员运算符。因为 unique_ptr 指向的是一个数组而不是单个对象，但我们可以使用下标运算符来访问数组中元素：

```c++
for (size_t i = 0; i != 10; ++i) {
    up[i] = i; // 为每个元素赋予一个新值
}
```

与 unique_ptr 不同，shared_ptr 不直接支持管理动态数组。如果希望使用 shared_ptr 管理一个动态数组，必须提供自己自定义的删除器：

```c++
shared_ptr<int> sp(new int[10], [](int *p) { delete [] p; });
sp.reset();
```

shared_ptr 未定义下标运算符，而且只能指针类型不支持指针算数运算。因此，为了访问数组中元素，必须用 get 获取一个内置指针，然后用它来访问数组元素。