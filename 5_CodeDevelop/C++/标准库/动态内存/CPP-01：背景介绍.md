我们编写的程序中所使用的对象都有着严格定义的生存期。包括全局对象与局部对象的创建于销毁。

- 全局对象：程序启动时分配内存，程序结束时销毁。
- 局部自动对象：进入其定义所在的程序块时被创建，在离开块时销毁。
- 局部 static 对象：在第一次使用前分配，在程序结束时销毁。

于此之外，C++ 还支持动态分配对象。动态分配的对象的生存期与它们在哪里创建是无关的，只有当显式地被释放时，这些对象才会销毁。

动态对象的正确释放被证明是编程中及其容易出错的地方。为了更安全地使用动态对象，标准库定义了两个智能指针来管理动态分配的对象。当一个对象应该被释放时，指向它的智能指针可以确保自动地释放它。

我们的程序目前为止只使用过静态内存或栈内存。

- 静态内存：保存局部 static 对象、类 static 数据成员、定义在任何函数之外的变量。
- 栈内存：保存定义在函数内的非 static 对象。

**分配在静态或栈内存中的对象由编译器自动创建和销毁**。

除以上外，每个程序还拥有一个内存池，这一块的内存被称作自用空间或堆（heap）。程序用堆来存储动态分配的对象，即那些在程序运行时分配的对象。动态对象的生存期由程序来控制，也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。

---

在 C++中，动态内存地管理是通过一对运算符来完成地：new，在动态内存中为对象分配空间并返回一个指向该对象地指针，我们可以选择对对象进行初始化；delete，接受一个动态对象的指针，销毁该对象，并释放与之相关联的内存。

但动态内存的使用是很容易出问题，因此为了安全容易使用动态内存，新的标准库提供了两种智能指针（smart pointer）类型来管理动态对象。智能指针的行为类似常规指针，重要的区别式它负责自动释放所指向的对象。

新标准库提供的两种智能指针的区别在于**管理底层指针的方式**：

- shared_ptr：允许多个指针指向同一个对象
- unique_ptr：独占所指向的对象。
- weak_ptr：弱引用，指向 shared_ptr 所管理的对象

这三种类型都定义在 memory 头文件中。