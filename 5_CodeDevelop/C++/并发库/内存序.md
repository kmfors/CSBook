`std::memory_order` 指定内存访问，包括常规的非原子内存访问，如何围绕原子操作排序。

在没有任何制约的多处理器系统上，多个线程同时读或写数个变量时，一个线程能观测到变量值更改的顺序不同于另一个线程写它们的顺序。其实，更改的顺序甚至能在多个读取线程间相异。一些类似的效果还能在单处理器系统上出现，因为内存模型允许编译器变换。

库中所有原子操作的默认行为提供序列一致顺序。该默认行为可能有损性能，不过可以给予库的原子操作额外的 `std::memory_order` 参数，以指定附加制约，在原子性外，编译器和处理器还必须强制该操作。

# 内存序常量值



|           value           |    内存顺序     |                         描述                         |
| :-----------------------: | :---------: | :------------------------------------------------: |
| memory_order_relaxed：<br> |   无序的内存访问   |   不做任何同步，仅仅、保证该原子类型变量的操作是原子化的，并不保证其对他线程的可见性和正确性    |
|   memory_order_consume    | 与消费者关系有关的顺序 | 保证本次读取之前所有依赖于该原子类型变量值的操作都已完成，但不保证其他线程对该变量的存储结果已经可见 |


- memory_order_relaxed：不做任何同步，仅保证该原子类型变量的操作是原子化的，并不保证其对其他线程的可见性和正确性。
- memory_order_consume：使用复杂，不推荐学习
- memory_order_acquire：保证本次读取之前，所有先于该原子变量的线程写入操作都已经完成，其他线程对该变量的存储结果可为当前线程所见。
- memory_order_release：保证本次写入之后，所有后于该原子变量的线程读取操作都已经完成，当前线程对该变量的存储结果可为其他线程所见。
- memory_order_seq_cst：保证本次操作以及之前和之后的所有原子操作都按照一个全局的内存顺序执行，从而保证多线程环境下对变量的读写的正确性和一致性。这是最常用的内存顺序。

先搬出并发三特性：原子性、顺序性、可见性。

列举 6 种：

memory_order_relaxed: 可对应 load 和 store 操作。保障原子性和可见性，不保障顺序性

memory_order_acquire: 仅对应于 load 操作，保障原子性和可见性，及部分的顺序性(后面的操作不能跑到该指令的前面去)

memory_order_release：仅对应于 store 操作，保障原子性和可见性，及部分的顺序性(前面的操作不能跑到该指令的后面去)

memory_order_acq_rel：可对应 load 和 store 操作，保障原子性、可见性和顺序性(相当于 memory_order_acquire 与 memory_order_release 的叠加)

memory_order_seq_cst： 可对应 load 和 store 操作。效果大于 memory_order_acq_rel，具体的区别是，顺序一致性在通知变量失效时具有排他性

memory_order_consume：不建议使用

