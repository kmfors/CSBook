# CPP-01: 命名空间

## 概念介绍

如果在同一程序中引入两个相同的标识符，编译器或链接器无法将它们区分开来，编译器或链接器就会产生错误。这种错误一般被称为 **命名冲突**。

- 如果冲突的标识符被引入同一个文件，其结果将导致编译器报错。
- 如果冲突的标识符被引入属于同一程序的不同文件，则会导致链接器错误。

为了解决命名冲突，C++提供了 **命名空间** 机制。

**作用域**（scope region）是源代码的一个区域，在这个区域中，所有已声明的标识符都被认为与其他作用域中声明的名称不同。

两个同名的标识符可以在不同的作用域中声明，而不会造成命名冲突。但是在给定的作用域区域内，所有标识符必须是唯一的，否则将导致命名冲突。例如：每个函数都提供了一个独立的作用域即函数体。

**命名空间** 则是另一种作用域区域，允许在其中声明名称，以达到消除歧义的目的。在命名空间内声明的任何名称都不会被误认为是其他作用域中的相同名称。

`::` 称为作 **用域解析运算符**。 `::` 符号左边的为命名空间，右边为命名空间内的标识符。 **如果没有提供 `::` 符号左边的名称，则假定使用全局名称空间。**


命名空间的语法如下：(建议命名空间以大写字母开头，且名称小写)

```c++
namespace NamespaceIdentifier
{
    // content of namespace here
}
```

> [!TIP]
>
> 1、命名空间的作用域中只能出现声明和定义（不能出现可执行语句）。
>
> 2、定义在命名空间的变量、函数、结构体、类等等，统称为实体。而对命名空间的访问：`namespace::`。
>
> 3、如果不使用作用域限定符和 `using` 机制，抛开名称空间嵌套和内部屏蔽的情况，实体的可见域是从实体创建到该名称空间结束，而在名称空间外，该实体是不可见的。




## 使用方式

命名空间一共有三种使用方式，分别是 `using` 编译指令、作用域限定符、`using` 声明机制。

### using 编译指令

**using 编译指令，将标准命名空间 std 中的实体全部引出来。** 注意：自定义的实体不要与标准命名空间 std 中的实体冲突。

```c++
using namespace std;	// 引入 std 全部实体

namespace Foo {
int number = 10;
void print() {
    // 引入 std 可直接使用 cout、endl
    cout << "void print()" << endl; 
}

}//end of namespace Foo
```

### 作用域限定符

直接使用作用域限定符 `::` ，每次要使用某个名称空间中的实体时，都直接使用作用域限定符引出。

```c++
namespace Foo {
int number = 10;
void display() {
    // cout, endl 都是 std 空间中的实体
    std::cout << "Foo::display()" << std::endl;
}

}//end of namespace Foo
```


### using 声明机制

using 声明机制的作用域是从 using 语句开始，到 using 所在的作用域结束。要注意，在同一作用域内用 using 声明的不同的命名空间的成员不能有同名的成员，否则会发生重定义。

```c++
#include <iostream>

using std::cout; // 需要哪个实体的时候就引入到程序中
using std::endl; // 需要哪个实体的时候就引入到程序中

namespace Foo {
int number = 10;
void display() {
    cout << "Foo::display()" << endl;
}

}//end of namespace Foo

using Foo::number;
using Foo::display;

int main(void) {
    cout << "Foo::number = " << number << endl;
    Foo::display();
}
```



## 特殊介绍

### 全局命名空间

在 C++ 中，任何没有在类、函数或命名空间中定义的名称都被视为 **隐式定义的命名空间** 的一部分，该命名空间称为 **全局命名空间**（也称为全局作用域）。

- 在全局作用域内声明的标识符，它的作用域从声明点到文件（`.cpp`）结束。
- 虽然可以在全局命名空间中定义变量，但一般情况下应避免这样做。

### 匿名命名空间

不定义名字的命名空间称为匿名命名空间。由于没有名字，该空间中的实体，其它文件无法引用，**它只能在本文件的作用域内有效**，它的作用域是从匿名命名空间声明开始到本文件（`.cpp`）结束。

在本文件使用匿名空间成员时，不必用命名空间限定。其实匿名命名空间和 static 是同样的道理，都是只在本文件内有效，无法被其它文件引用。

**在匿名空间中创建的全局变量，具有全局生存期，却只能被本空间内的函数等访问**，是 static 变量的有效替代手段。


## 应用拓展

### 命名空间的嵌套及覆盖


```c++
int number = 10; //全局变量

namespace Foo {
int number = 20;
void print(int number) {
    cout << "形参number = " << number << endl;
    cout << "命名空间CS中的number = " << Foo::number << endl;
    cout << "全局变量number = " << ::number << endl;//全局命名空间 
}

}//end of namespace
```

如果在命名空间内，访问 **未使用作用域限定符** 的实体：

1. 编译器将首先尝试在同一名称空间内查找匹配的声明。
2. 继 step1，如果未找到，编译器将依次检查每个包含该标识符的命名空间，查找匹配的标识符。
3. 继 step2，如果未找到，最后检查全局命名空间。

在分离式编译的两个文件中，如果函数的声明没有放在指定的名称空间（例如 `Foo`），定义放了，则该函数将在全局命名空间中声明，编译报错没有调用 `Foo` 下的函数的声明；反之，链接器报错无法为 `Foo` 下的函数调用找到匹配的定义。

命名空间内是可以嵌套新的命名空间的。


## 总结

- 提倡在已命名的名称空间中定义变量，而不是直接定义外部全局变量或者静态全局变量。
- 如果开发了一个函数库或者类库，提倡将其放在一个名称空间中。
- 对于 using 声明，首先将其作用域设置为局部而不是全局。
- 不要在头文件中使用 using 编译指令，这样使得可用名称变得模糊，容易出现二义性。
- 包含头文件的顺序可能会影响程序的行为，如果非要使用 using 编译指令，建议放在所有 `#include` 预编译指令后。