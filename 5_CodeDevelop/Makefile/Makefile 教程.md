# 预定义变量

在 Makefile 中，`CXX` 与 `CXXFLAGS` 通常都是一个预定义的变量，CXX 用于指定 C++ 编译器的名称；CXXFLAGS 用于存储 C++ 编译器的选项。

编译器的编译选项都有：（注意编译选项前添加短横线）

- `g`：生成调试信息，以便在调试时使用。
- `I`：指定编译文件的头文件路径
- `O0`：关闭优化，这将使得编译后的程序更容易进行调试。
- `std=c++11`：指定使用 C++11 标准进行编译。
- `Wall`：打开所有警告信息，让编译器尽可能多地发出警告。
- `Wno-deprecated`：忽略已弃用的特性的警告。
- `Wno-unused-but-set-variable`：忽略未使用但被赋值的变量的警告。


# 指定头文件路径

- `-I./`：表示当前目录，告诉编译器在当前目录中查找头文件。
- `-I$(PATH_COMM)`、`I$(PATH_NET)`、`I$(PATH_CODER)`：这些都是指定路径下的头文件目录，告诉编译器在这些路径下查找对应的头文件。

`-I` 选项后面应该紧跟着路径，而不能有空格。这是因为 Makefile 中的命令解析通常会根据空格来分割参数，所以如果在 `-I` 后面有空格，编译器就会将空格后面的内容误认为是路径的一部分，导致无法正确识别头文件路径。这样设置 **`CXXFLAGS`** 变量可以确保编译器在编译时能够正确地找到项目中所需的头文件。


# 指定 obj 文件路径

obj 文件是源文件经过编译后生成的文件，但是在命名以及存放位置上还需要学习怎么处理。牵扯的学习点：模式匹配以及通配符的使用。

**模式替换**函数 `patsubst`：在 **`text`** 中寻找符合 **`pattern`** 的部分，并用 **`replacement`** 进行替换。其中，**`pattern`** 是一个模式字符串，可以包含通配符 `%`（表示匹配任意长度的字符序列）。

```makefile
$(patsubst pattern, replacement, text)
```


**获取文件**函数 `wildcard`：用于获取指定目录下的文件列表。其中，**`pattern`** 是一个文件名模式，可以包含通配符 **`*`** 和 **`?`**，用于匹配文件名。

```makefile
$(wildcard pattern)
```

以上两种可搭配使用用于指定 obj 文件路径，例如

```Makefile
COMM_OBJ := $(patsubst $(PATH_COMM)/%.cc, $(PATH_OBJ)/%.o, $(wildcard $(PATH_COMM)/*.cc))
```

**获取 PATH_COMM 路径下的所有 cc 文件，并将 cc 文件对应编译生成的 obj 文件放置到 PATH_OBJ 目录中。函数的返回结果为COMM_OBJ，即指定目录下的 obj 文件列表。**

通配符说明：`%`、`*`  和  `?`  是用于模式匹配的通配符，它们在 Makefile 中具有不同的含义和用法。

1. `%`：表示任意长度的字符序列。例如，`%.o : %.c`  表示匹配所有 `.c` 文件并依赖于对应的 `.o` 文件。
2. `*`：**通常用在文件名模式中，用于匹配任意长度的文件名**。例如，`*.c` 表示匹配所有以 `.c` 结尾的文件。
3. `?`：匹配单个字符。例如，`??.c` 表示匹配所有名字长度为 2 且以 `.c` 结尾的文件。

综上所述，**`%`**、**`*`** 和 **`?`** 在 Makefile 中都是用于模式匹配的通配符，但它们的匹配范围和具体含义略有不同。 **`%`** 主要用于模式规则中，**`*`** 和 **`?`** 则用于文件名模式中。

# 编译目标文件

众所周知，编译目标文件时，源文件无非是 cc 或 cpp 或 obj 文件，因此不同类型的文件也有着不一样的处理，但区别不大。

```Makefile
PATH_COMM_SRC := $(wildcard $(PATH_COMM)/*.cc)
PATH_COMM_OBJ := $(patsubst $(PATH_COMM)/%.cc,$(PATH_OBJ)/%.o,$(PATH_COMM_SRC))
```

**编译 obj 文件**： `OBJ_PATH/%. o : SRC_PATH/%. cc`

```Makefile
$(PATH_OBJ)/%.o : $(PATH_COMM)/%.cc
    $(CXX) $(CXXFLAGS) -c $< -o $@
```

- 目标通过 % 通配符匹配相同部分的依赖，路径下所有文件都遵循这个规则
- 会逐个编译每个源文件, 可以将上面想象为 for 循环

**错误的编译方式**：`OBJ_FILES_LIST : SRC_FILES_LIST`  问题：这个规则试图将所有的源文件一起编译成一个目标文件，但是 -o 选项只能用于单个源文件的编译。

```Makefile
$(PATH_COMM_OBJ) : $(PATH_COMM_SRC)
    $(CXX) $(CXXFLAGS) -c $^ -o $@
```

正确的编译方式： obj 文件列表是用来编译最后的可执行程序的

```Makefile
$(TARGET): $(OBJ_FILES)
    $(CXX) $(CXXFLAGS) $^ -o $@
```

#  `$<` 与 `$^` 的区别：

在 Makefile 中，**`$<`** 和 **`$^`** 都是自动变量，用于表示规则的依赖文件：

- `$<` ：表示规则中的第一个依赖文件（即源文件）。
- `$^` ：表示规则中的所有依赖文件（即源文件和其他依赖文件）。

`$<` 适用于编译单个文件（第一个依赖文件），而 `$^` 适用于编译多个的文件列表。`$^` 可以替代 `$<` 做它的事情，但是 `$<` 无法代替 `$^` 做它的工作。


# Makefile 的= 、:=、+=、?= 区别

在 Linux 的 shell 里，shell 只认识字符串

1、**"="**  延时变量：Make 会将整个 makefile 展开后，再决定变量的值。也就是说，变量的值将会是整个 makefile 中最后被指定的值。看例子：

```Makefile
x = foo
y = $(x) bar
x = xyz
```

在上例中，y 的值将会是 `xyz bar` ，x 的值为 `xyz`。使用 = 定义的变量是"递归赋值"的。这意味着，变量的值在使用时会进行递归展开。

2、**":="**  立即变量：表示变量的值决定于它在 makefile 中的位置，而不是整个 makefile 展开后的最终值。

```Makefile
x := foo
y := $(x) bar
x := xyz
```

在上例中，y 的值将会是 `foo bar` ，x 的值为 `xyz`。`:=` 赋值只发生一次，且值在整个 Makefile 中保持不变。

**在实际使用中，如果你希望变量的值在定义时就被确定下来，不希望受到后续改变的影响，通常会使用 := 来定义变量。这可以提高 Makefile 的可读性和可维护性，避免意外的展开结果。而使用 = 来定义变量时，则需要注意可能带来的递归展开问题。**

3、"+="  追加变量：

4、"?="  如果没有被赋值过就赋予等号后面的值


# 特别说明

1、**`O0`** 是一个编译选项，它指示编译器在不进行优化的情况下编译代码。通常，编译器会尝试对代码进行各种优化，以提高程序的性能和效率。这些优化可能包括代码重排、函数内联、循环展开等。但在调试阶段，关闭优化（即指定`-O0`选项）是很有用的，因为它可以保留源代码和编译后的目标代码之间的直接映射，使得调试更加方便。如果启用了优化，编译器可能会对代码进行重排或者进行一些其他的优化，这可能会导致源代码和目标代码之间的对应关系变得模糊，使得调试变得困难。 因此，在调试阶段，为了获得更好的可读性和调试能力，关闭优化是一个常见的做法

2、添加依赖的头文件

```Makefile
%.o : %.c XXX. h
    gcc -IM -c $@ $<
```

1、头文件放到依赖位置；
2、编译时添加“-IM”选项，一定要大写。

